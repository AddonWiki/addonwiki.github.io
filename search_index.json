[{"path":"主页.md","content":"# **AddonWiki**\n## **附加包维基**\n*****\n*Hello Everyone*，欢迎访问本站。\n本站大部分围绕MinecraftBedrock基岩版的Addon附加包相关内容，也会有少部分Addon附加包以外的基岩版内容。\n![](https://img.imgdb.cn/item/60138c2d3ffa7d37b336b383.png)\n\n### **导航**\n[主页]()：This\n[Addon入门教程]()：将会对Addon整体概念与基础内容进行讲解，分为1.AddOns基础知识、2.AddOns组成结构、3.自定义游戏内容、4.后期 四个章节\n[基础概念]()：认识语言文件、命令函数以及结构文件，并初步了解组件、组件组、事件三大巨头\n[名词解释]()：各类专业名词的解释\n[专辑篇]()：对之前入门教程草草了事的部分以及其它较难的地方进行详细深入讲解，如交易列表、战利品表（掉落物表）、实体生成、滤器、触发器与事件等。\n[脚本引擎]()\n[技巧]()\n[AddonAPI文档]()\n\n### **关于**\nBy BIYUEHU，本站所有文章严禁转载、二次发布等\nMyBlog：[源](https://biyuehu.github.io)、[国内镜像](https://biyuehu.gitee.io)\nBilibili：[碧月狐dada](https://space.bilibili.com/293767574)\n\n### **贡献**\n目前由我一人维护、编写文档教程，目前还有少部分文档不太完善或有错误。如若您有一定能力可以帮助、完善文档\n","title":"主页"},{"path":"Addon入门教程.md","content":"### **本教程目录**\r\n#### 1.AddOns基础知识\r\n##### 1-1.AddOns附加包的定义与发展史\r\n##### 1-2.JSON基础认识  \r\n##### 1-3.工具准备\r\n\r\n#### 2.AddOns的组成结构\r\n##### 2-1.第一个包!\r\n##### 2-2.导入与测试\r\n\r\n#### 3.自定义游戏内容\r\n##### 3-1.自定义物品\r\n##### 3-2.自定义方块\r\n##### 3-3.自定义配方\r\n###### 3-3-1.自定义合成\r\n###### 3-3-2.自定义熔炼\r\n###### 3-3-3.自定义切石机\r\n###### 3-3-4.自定义酿造台\r\n###### 3-3-5.自定义制图台\r\n##### 3-4.自定义生成结构\r\n###### 3-4-1.自定义生物群系\r\n###### 3-4-2.自定义树特征\r\n###### 3-4-3.自定义矿石特征\r\n###### 3-4-4.自定义结构特征\r\n##### 3-5.自定义实体\r\n###### 3-5-1.组成结构\r\n###### 3-5-2.行为包部分-实体行为(必选)\r\n###### 3-5-3.行为包部分-实体生成(可选)\r\n###### 3-5-4.行为包部分-实体掉落物(可选)\r\n###### 3-5-5.资源包部分-实体资源包定义(必选)\r\n###### 3-5-6.资源包部分-材质(可选)\r\n###### 3-5-7.资源包部分-模型(可选)\r\n###### 3-5-8.资源包部分-贴图(可选)\r\n###### 3-5-9.动画\r\n###### 3-5-10.动画控制器\r\n###### 3-5-11.资源包部分-渲染控制器(可选)\r\n###### 3-5-10.动画控制器\r\n##### 3-6.自定义颗粒效果\r\n##### 3-7.自定义音乐与音效\r\n\r\n\r\n\r\n#### 4.后期篇\r\n###### 4-1.Addon加密\r\n###### 4-2.Addon发布","title":"Addonr入门教程"},{"path":"Addon教程前言.md","content":"## **前言**\r\n本贴将会更新MINECRAFTBE基岩版的Add-Ons附加包教程\r\n欢迎您的关注!\r\n\r\n本文章内容部分摘自[**MinecraftWiki**](https://minecraft-zh.gamepedia.com/Minecraft_Wiki)\r\n\r\n如若文章有错误地方欢迎各位大佬指出！\n有时间会尽量更新教程，但只确保可适用于正式版，阅读之前请先确保您的版本与教程适用的版本一致\n*目前可适用版本：正式版1.16.200.2*\n配合AddonAPI文档一起食用，效果更佳\n\r\n\r\n**版权@2020-2021 BIYUEHU，本文档严禁转载**\n\n\r\n\r\n### **对于某些人**\r\n如果你学Add-Ons只是<font color=\"#FF0000\">**纯属为了恰烂钱（仅批评用低质量作品骗钱,不包括做精品收费一类的）或者没有打算努力研究下去的恒心</font>** 的话都**爬! 爬!! 爬!!!**\n\n\r\n\r\n### **基础要求**\r\n**确保您会使用您的系统或设备，而不是只会用来玩玩游戏看看视频**\r\n**确保您会文件管理与文件编辑**\r\n**确保您有足够的耐心与恒心**\r\n**熟能生巧，确保每看完一篇教程后你都能亲自动手写一写**","title":"0.Addon入门教程前言"},{"path":"1.AddOns基础知识.md","content":"### **本章目录**\n#### 1.AddOns基础知识\r\n##### 1-1.AddOns附加包的定义与发展史\r\n##### 1-2.JSON基础认识  \r\n##### 1-3.工具准备","title":"1.AddOns基础知识"},{"path":"1-1.AddOns附加包的定义与发展史.md","content":"### 定义\r\n**附加包（Add-on）**是朝向Minecraft全版本自定义的坚实一步，它受Mojang官方支持。由资源包+行为包组成。目前，还只有基岩版的平台支持附加包(包括Windows 10、Gear VR和Fire TV)。这些版本现在允许玩家去更改他们世界的样貌（材质）、改变物品及生物的模型、修改生物的行为，这些功能都可以通过资源包和行为包来实现。此处提供的文档受官方支持与核实，是由Minecraft开发团队提供籍以协助社区发布的。\r\n\r\n\r\n\r\n**以上改编自[MinecraftWIKI](https://minecraft-zh.gamepedia.com/%E9%99%84%E5%8A%A0%E5%8C%85)**\n*****\n\r\n\r\n\r\n如果您玩过**JAVA版**，那么您可以把附加包理解为JAVA版的**数据包**\r\n说来很巧，**附加包**与**数据包**在许多地方都有相似之处\r\n首先它们都使用的**JSON**,其次也都是**官方**的而非第三方,也无需任何多余的**启动器**或**框架**才能加载**原版**即可。\n\n\r\n至于两者**谁强谁弱**，这也无法一口肯定\r\n在有些地方数据包远远胜过了附加包（如数据包在1.16加入的自定义维度）,也有些地方则相反（如附加包的精华部分——实体）\n*****\n\r\n\r\n\r\n\r\nAddon大部分文件均由**JSON**编写\r\n在1.9.0.3beta加入了前所未有的的**JavaScript脚本引擎**，虽然现在也不怎么完善，也只对WINDOWS10平台开放，安卓需使用方启加载，IOS彻底没救。但也让开发者不再受限于第三方的MODAPI。\r\n(比如IC/HZ与张卓伟的方块启动器的MODPE)\r\n除此之外，JavaScripts脚本引擎的**experimental_ui**基于HTML5，因此还会涉及到HTML与CSS等语言\n\r\n\r\n### **基岩版\"MODAPI框架\"**\r\n在JAVA版中有许多的MODAPI框架,如:Forge,Fabric...\r\n而基岩版也是如此，也有许多形形色色的”MODAPI“\r\n\r\n\r\n\r\n#### **官方:**\r\n#####  Addon附加包（MOJANG）\n+ 资源包（Resource_Pack）\n+ +  材质包\n+ +  着色器（光影）\n+ +  语言包\n+ +  音乐包\n+ 行为包（Behavior_Pack）\n+ + Function命令函数\n+ + Script Engine脚本引擎（JavaScript）\n\r\n##### Python MOD （网易,基于Addon）\n\r\n\r\n\r\n\r\n#### **第三方**\r\n##### 外置型:\r\n###### BlockLauncher方块启动器\r\n###### GenericLauncher\r\n###### Toolbox\r\n###### ModdedPE\r\n\r\n##### 内嵌型:\r\n##### InnerCore\r\n\r\n#### 实例型:\r\n###### Horizon\r\n\r\n\r\n#### 服务器\r\n\r\n###### 基于官方BDS基岩版专用服务端:\r\n**Bedrock Delicated Launche(加载BDLMOD)**\r\n**Element Zer(有EZDLL、EZJS等分支)**\r\n**BDX(有BDXJS、BDXDLL、BDXLua、BDXGLang等分支)**\r\n**BDXC**\r\n**梦故加载器(有梦故DLL、梦故JSRunner等分支)**\r\n**CSR**\n**Pyr**\n**Ipyr**\n\r\n\r\n###### 完全重写类:\r\n**mcpelauncher-server**\r\n**mcpeserver**\r\n**Naïve**\r\n**PocketMine**\n\r\n**PocketMine MP**\r\n**Cobblestone Server**\r\n**NukkitX**\r\n\r\n\r\n**网易的MOD SDK API**\r\n网易干啥啥不行，但API却十分nice。不仅为原版Addon提供更多的扩展API(当然，本文章仅讲国际版的API)，还有网易的**Pymod**(python mod)，也是基于Addon，由Python语言编写，有更多的逻辑。\r\n\r\n\r\n\r\n*****\n### 前世今生(发展史)\r\n自从Minecraft的原始Java版早期开发以来，已经计划为开发人员实现添加和更改游戏内容的官方方式。官方游戏定制的计划可以追溯到2010年7月5日的Alpha v1.0.1_01，在发布之后计划称为Mod API。 据说它在Beta 1.8中发布。然后将Mod API重新命名为插件API，最初声明计划用于1.3的版本，然后用于1.4版本，然后由Curse意外地声明它将在1.5中实现。\r\n\r\n在MINECON 2012，Mojang分享了他们对插件API未来的愿景。该API将由Bukkit团队开发并旨在简化模型和下载过程，虽然包含稍微有限的功能集。最初发布开发者网站后 (http://dev.minecraft.net) 和GitHub页面，这些都在一年内被删除。\r\n\r\n开发人员曾多次提到，游戏代码中的许多更改都在准备插件API，包括2014年7月29日的Dinnerbone、Grum于2015年7月5日在“The Minecraft Team - Behind the Scenes”小组讨论和2015年10月19日，在Java版1.9的战利品表上工作时再次和Dinnerbone。一位用户回复说“我认为官方回复‘我们正在努力’真的会有很多帮助”。Dinnerbone回答说：“我们正在努力。”\r\n\r\n2016年8月12日，Searge发推文说：“MINECON 2016上将会有关于API的消息。我会谈谈我正在研究的事情以及我们的计划。但现在没有更多细节。“第二天，Grum证实了携带版上的这一点。Minecon上概述了附加组件开发的计划和路线图。\r\n\r\n**以上摘自[MinecraftWIKI](https://minecraft-zh.gamepedia.com/%E9%99%84%E5%8A%A0%E5%8C%85)**\r\n","title":"1-1.AddOns附加包的定义与发展史"},{"path":"1-2.JSON基础认识.md","content":"![JSON](https://pic.downk.cc/item/5f2fdb4814195aa594dd8bf4.jpg)\r\n**JSON(JavaScript Object Notation, JS 对象简谱)** 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\r\n\r\n中文名：JavaScript 对象简谱\r\n外文名：JavaScript Object Notation\r\n缩写：JSON\r\n\r\n**以上摘自[百度百科](https://baike.baidu.com/item/JSON/2462549?fr=aladdin)**\n*****\n\r\n\r\n### **JSON 语法**\r\n```json\r\n{\r\n  \"姓\": \"菜\",\r\n  \"名\": \"徐坤\",\r\n  \"男的?\": false,\r\n  \"年龄\": 1,\r\n  \"爱好\": [ \"唱\", \"跳\", \"rap\" ]\r\n}\r\n\r\n```\r\n**JSON**一共包括五种结构\r\n分别为**对象、字符串、布尔值、数字、数组**\r\n\r\n#### **对象**\r\n**对象**将会被花括号{ }所包囊，里面由**键**与**值**组成\r\n**键**为预先定义的属性，需要用被英文引号\"\"包囊。\r\n**PS:JSON里一切符号均为英文符号，不支持中文符号**\r\n在栗子里，姓、名、男的？、年龄、爱好 均为键。\r\n\r\n#### **值**\r\n**值**一共有四种类型，分别为：字符串、布尔值、数字、数组。\r\n\r\n##### **字符串**\r\n**字符串**会被英文引号\"\"包囊\r\n\r\n##### **布尔值**\r\n**布尔值**共有两种类型：\r\n**true**（真）与**false**（假）\r\n无需引号包囊\r\n\r\n##### **数字**\r\n顾名思义，可以为整数、负数、浮点数（即小数），将由**键**决定。\r\n无需要引号包囊\r\n\r\n##### **数组**\r\n由方括号[ ]包囊，至于方括号里面的**值**也依然可以为字符串、布尔值、数字、数组。\r\n\r\n没错，你可以无限套娃！当然，玩梗适度，反复套来套去确实可以实现一些逻辑。\r\n\r\n\r\n\r\n\r\n\r\n### **JSON注释**\r\nMINECRAFT对**JSON**文件**支持**\r\n单行注释//\r\n与\r\n/* 和 */ 组合的注释\r\n栗子:\r\n```json\r\n{\r\n    //我是一个注释\r\n\r\n    /*\r\n    从这\r\n\r\n\r\n\r\n    到这都是注释\r\n    */\r\n}\r\n\r\n```\r\n\r\n<font color=\"#FF0000\">注意：在正规的JSON中是不存在注释的，用在普通JSON文件里将会是错误。但是，MC特意支持了这种注释，依然可以被解析。</font>\r\n\r\n\r\n\r\n\r\n\r\n","title":"1-2.JSON基础认识"},{"path":"1-3.工具准备.md","content":"在**AddOns开发**时肯定是需要用到各式各样的工具的\r\n### WINDOWS10平台(建议)：\r\n\r\n**绘图工具：**\r\nAdobe Photoshop CC，画图3D(WIN10自带)\r\n\r\n**文件管理器：**\r\nWINDOWS自带 文件资源管理器\r\n\r\n**文本编辑器：**\r\n~~JSON不像C艹,JVAV~~这些语言要配置环境，你甚至可以用记事本来编辑json!但十分不建议。\r\n你可以选择Notepad++，Visual Studio Code这些优秀的文本编辑器\r\n\r\n**建模：**\r\nBlockbench\r\n\r\n\r\n### 安卓：\r\n\r\n**绘图工具：**\r\n像素小画家\r\n\r\n**文件管理器：**\r\nMT文件管理器，ES文件管理器\r\n\r\n**文本编辑器：**\r\n文件管理器自带的即可\r\n\r\n**建模：**\r\nBlockbench（网页）\r\n\r\n\r\n### IOS：\r\n抬走不送","title":"1-3.工具准备"},{"path":"2.AddOns组成结构.md","content":"### **本章目录**\n#### 2.AddOns的组成结构\r\n##### 2-1.第一个包!\r\n##### 2-2.导入与测试","title":"2.AddOns组成结构"},{"path":"2-1.第一个包.md","content":"**Addon**基本组成部分如下:\r\n\r\n#### Behavior_Pack\r\n+ animation_controllers //动画控制器(服务端)\r\n+ animations //动画(服务端)\r\n+ biomes //生物群系属性定义\r\n+ blocks //方块属性定义\r\n+ entities //实体行为属性定义\r\n+ feature_rules //生成规则\r\n+ features  //生成特征\r\n+ functions  //function指令，用于一次性执行多条指令\r\n+ items  //物品属性定义\r\n+ loot_tables  //战利品定义\r\n+ recipes  //配方定义\r\n+ scripts  //JS脚本\r\n+ spawn_rules //生物生成定义\r\n+ trading  //交易列表定义\r\n+ loot_tables  //战利品定义\r\n+ manifest.json  //包识别（描述）文件\r\n+ pack_icon.png  //包图标\r\n+ bug_pack_icon.png  //包出问题后的图标\n\n\r\n\r\n#### Resource_Pack\r\n+ animation_controllers //动画控制器(客户端)\r\n+ animations //动画(客户端)\r\n+ attachables  //穿戴物品定义\r\n+ entity  //实体定义\r\n+  experimental_ui  //实验UI\r\n+ font  //游戏内特殊标识符\r\n+ items  //物品视觉属性定义\r\n+ materials  //材料\r\n+ models  //模型\r\n+ particles  //粒子效果属性定义\r\n+ render_controllers  //渲染控制器属性定义\r\n+ sounds  //音效,音乐存放\r\n+ texts  //lang语言文件存放\r\n+ textures  //贴图存放\r\n+ ui  //用户界面定义\r\n+ shaders  //着色器\r\n+ credits  //终末之诗文字存放\r\n+ biomes_client.json  //不同生物群系的天空和水颜色\r\n+ block.json  //方块定义\r\n+ contents.json  \r\n+ items_offsets_client.json  \r\n+ loading_messages.json  //加载世界时的提示语\r\n+ sounds.json  //音效,音乐定义\r\n+ splashes.json  //小标题\r\n+ manifest.json  //包识别（描述）文件\r\n+ pack_icon.png  //包图标\r\n+ bug_pack_icon.png  //包出问题后的图标\r\n\n\r\n\r\n不要看到这么多文件夹与文件就头昏，并不是全都要用上的，如果只是一个能被**识别与装载**的包只需要一个描述文件manifest.json。\n### 题外话\n附加包 = 行为包 + 资源包，资源包/行为包 ≠ 附加包\n附加包是行为包与资源包结合后的称呼，除资源包与行为包外还有皮肤包（Skin_pack）与世界模板（world_template）\n*****\n\r\n\r\n首先**新建**一个文件夹，名字随意\r\n![1](https://pic.downk.cc/item/5f16a47114195aa594c509c1.png)\r\n![2](https://pic.downk.cc/item/5f16a47114195aa594c509c3.png)\r\n\r\n### manifest.json\r\n首先最好在文件管理器里把这两个选项勾上\r\n![3](https://pic.downk.cc/item/5f16a47114195aa594c509c5.png)\r\n\r\n\r\n接着新建一个txt文件，名字带后缀改成”manifest.json“\r\n\r\n![4](https://pic.downk.cc/item/5f16ac3814195aa594c8808c.png)\r\n此时windows可能会有弹窗提示，直接点击是\r\n\r\n\r\n然后输入以下代码:\r\n```json\r\n{\r\n    \"format_version\": 1,\r\n    \"header\": {\r\n        \"name\": \" \",\r\n        \"description\": \" \",\r\n        \"uuid\": \" \",\r\n        \"version\": [0, 0, 1]\r\n    },//\r\n    \"modules\": [\r\n        {\r\n            \"description\": \" \",\r\n            \"type\": \" \",\r\n            \"uuid\": \" \",\r\n            \"version\": [0, 0, 1]\r\n        }\r\n    ]\r\n}\r\n```\r\n**注意：**<font color=\"#FF0000\">不要直接复制到粘贴，先试着自己写一下找出感觉来！</font>\r\n\r\n#### **解释：**\n##### format_version，必选项\n定义了附加包的版本。除非必要，否则请勿更改写1即可\n##### header\n描述这个包的标题、简介、版本等信息，必选项\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| name | 包的标题 | 字符串 | null | 所有字符 |\n| description | 包的简介 | 字符串 | null | 所有字符 |\n| uuid | 包的唯一标识符，不能重复 | 字符串 | null | UUID |\n| version | 版本号 | 数组 | null | [主版本号, 次版本号, 修正版本号] |\n| base_game_version | 世界模板所适用的基础游戏版本 | 数组 | null | [主版本号, 次版本号, 修订号] |\n| lock_template_options | 任何世界模板都需要此选项。这将禁止玩家修改世界选项 | 布尔 | true | true或false |\n| min_engine_version | 此包适配的最低游戏版本 | 字符串 | null | 字符串 |\n##### modules\n描述了组成附加包的各个模块，必选项\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| description | 包的简介，目前这并不是面向用户 | 字符串 | null | 所有字符 |\n| type | 包的类型 | 字符串 | null | resources、data、client_data、interface、world_template、skin_pack，分别对应资源包、行为包、行为包（开启脚本引擎）、界面、世界模板、皮肤包 |\n| uuid | 包的唯一标识符，不能重复 | 字符串 | null | UUID |\n| version | 版本号 | 数组 | null | [主版本号, 次版本号, 修正版本号] |\n**UUID**\nUUID是唯一标识符，用于区分不同的包，因此这不能重复\nuuid以xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx的格式写入，其中每个x是一个十六进制值（0-9或a-f）\n您可以前往[这里](https://biyuehu.gitee.io/uuid/)生成uuid\n##### dependencies\n指定该包的依赖项，仅资源包于行为包之间而言，可选项\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| uuid | 依赖包的唯一标识符，不能重复 | 字符串 | null | UUID |\n| version | 依赖包的版本号 | 数组 | null | [主版本号, 次版本号, 修正版本号] |\n##### capabilities\n附加包可以使用的其他功能，一般情况下，这些功能不一定启用。该项的值的类型为数组，可选项\n以下是目前可开启的其它功能\n| 名称  | 描述 |\n| --- | --- |\n| experimental_custom_ui | 允许附加包中的HTML文件自定义UI |\n| chemistry | 允许附加包添加、更改或替换有关化学的功能|\n##### metadata\n附加包的其他信息，可选项\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| authors | 包作者名字 | 数组 | null | |\n| license | 包协议 | 字符串 | null | 所有字符 |\n| url | 包相关链接 | 字符串 | null | 所有字符 |\n\r\n\r\n\r\n\r\n### pack_icon.png\r\n建议图片比例为1:1正方形\r\n推荐最小像素：16x16 推荐最大像素： 1024x1024","title":"2-1.第一个包!"},{"path":"2-2.导入与测试.md","content":"### 导入\r\n幸苦了这么久？那么包到底能不能用了？！\r\n只要您的json格式无误，那么答案是肯定的\r\n\r\n把您的包**压缩**一下\r\n\r\n![5](https://pic.downk.cc/item/5f16af8e14195aa594ca00b0.png)\r\n![6](https://pic.downk.cc/item/5f16af8e14195aa594ca00b2.png)\r\n后缀改成**mcpack**，接着双击一下看能不能导入到游戏里！\r\n\r\n**注：**安卓请先在设置-档案-存储位置选项改成外部。\r\n\r\n### 测试\r\nADDON制作时**bug**肯定是不可避免的\r\n但是mojang却非常善解人意\r\n\r\n在games/com.mojang你可能会发现有这三个文件夹:\r\n![7](https://pic.downk.cc/item/5f16b28414195aa594cad6d3.png)\r\n很多人可能都会忽略这个，但其实这是专门用来放测试资源的文件夹\r\n\r\n#### 有何不同？\r\n1.放在这些文件夹里的资源当被装到地图上时会**直接调用**，不会再复制一遍。\r\n2.在游戏时即可进行**改动**，重进存档后游戏会自动**重新加载**，而不需要退出游戏重进那么麻烦","title":"2-2.导入与测试"},{"path":"3.自定义游戏内容.md","content":"### **本章目录**\n#### 3.自定义游戏内容\r\n##### 3-1.自定义物品\r\n##### 3-2.自定义方块\r\n##### 3-3.自定义配方\r\n###### 3-3-1.自定义合成\r\n###### 3-3-2.自定义熔炼\r\n###### 3-3-3.自定义切石机\r\n###### 3-3-4.自定义酿造台\r\n###### 3-3-5.自定义制图台\r\n##### 3-4.自定义生成结构\r\n###### 3-4-1.自定义生物群系\r\n###### 3-4-2.自定义树特征\r\n###### 3-4-3.自定义矿石特征\r\n###### 3-4-4.自定义结构特征\r\n##### 3-5.自定义实体\r\n###### 3-5-1.组成结构\r\n###### 3-5-2.行为包部分-实体行为(必选)\r\n###### 3-5-3.行为包部分-实体生成(可选)\r\n###### 3-5-4.行为包部分-实体掉落物(可选)\r\n###### 3-5-5.资源包部分-实体资源包定义(必选)\r\n###### 3-5-6.资源包部分-材质(可选)\r\n###### 3-5-7.资源包部分-模型(可选)\r\n###### 3-5-8.资源包部分-贴图(可选)\r\n###### 3-5-9.动画\r\n###### 3-5-10.动画控制器\r\n###### 3-5-11.资源包部分-渲染控制器(可选)\r\n###### 3-5-10.动画控制器\r\n##### 3-6.自定义颗粒效果\r\n##### 3-7.自定义音乐与音效\n从本章开始，请务必与AddonAPI文档一起食用","title":"3.自定义游戏内容"},{"path":"3-1.自定义物品.md","content":"### 行为包\r\n首先在行为包目录创建“items”文件夹，接着在里面新建json文件（文件名字随意）\r\n\r\n```json\r\n{\r\n\"format_version\": \"1.16.200\",\r\n\"minecraft:item\": {\r\n  \"description\": {\r\n  \"identifier\": \"byh:item\"\r\n  },\r\n \r\n  \"components\": {}\r\n }\r\n}\r\n```\r\n\r\n#### 解释：\n##### format_version\n格式版本\n##### minecraft:item\n定义物品的各个模块，基础信息、组件等\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| description | 物品基础信息 | 对象 | null | |\n| components | 组件 | 对象 | null | |\n**组件**\n请参考AddonAPI文档，包括物品组件、方块组件、实体组件等\n###### description\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| identifier | 物品唯一标识符 | 字符串 | null | 命名空间:ID |\n| category | 物品分类 | 字符串 | null | items、equipment、natural、block、commands|\n| is_experimental | 需要开启实验玩法才能注册 | 布尔 | false | true或false |\r\n\r\n**命名空间**\r\n相当于**前缀**，会被应用到物品/方块/实体ID等地方\r\nMinecraft原版的命名空间即为“Minecraft”\r\n###### 有何用？\r\n假如两个附加包里都有个叫做“item”的物品，你是无法同时使用的，先加载哪个包才能先加载哪个物品\r\n此时，**命名空间**就有作用了，如果一个改为“a:item”,另一个改为\"b:item\"，这样就不会冲突\r\n命名空间和ID一样都可以是任何字母+数字，命名空间你可以写您的名字（英文或拼音）\n### 贴图与语言\n#### 新格式\n1.16.100及以上版本格式（选择该格式的话，行为包的item文件格式版本也需改成1.16.100及以上）\n在行为包的item文件组件中写入下列两个组件\n```json\n        \"components\": {    \r\n          \"minecraft:display_name\": {},//物品名字，可在{}内填写”value“: \"字符串\"直接定义（不建议），否则须在语言文件内定义\r\n          \"minecraft:icon\": { //物品贴图\r\n            \"texture\": \"byh:item\"  //值为字符串，贴图名字（不是贴图文件名字）\r\n          }   \n```\n接着在资源包根目录新建一个“textures”文件夹，在里面接着创建一个“item_texture.json”文件\r\n```json\r\n{\r\n  \"resource_pack_name\": \"vanilla\",\r\n  \"texture_name\": \"atlas.items\",\r\n  \"texture_data\": {\r\n    \"byh:item\": { //对应物品行为文件中minecraft:icon的texture的值\r\n      \"textures\": \" \"  //贴图位置，起始目录为资源包根目录\r\n    }\r\n  }\r\n}   \r\n\r\n```\n#### 旧格式\n1.16.100之前版本格式（选择该格式的话，行为包的item文件格式版本也需改成1.16.100之前）\n\r\n\r\n\r\n同样，在资源包根目录创建一个“items”文件夹，接着创建一个json文件。\r\n\r\n```json\r\n{\r\n  \"format_version\": \"1.16.0\",\r\n  \"minecraft:item\": {\r\n    \"description\": {\r\n      \"identifier\": \"byh:item\", //物品ID，要与行为包里的一致 \r\n      \"category\": \"Nature\"  //物品类型\r\n    },\r\n\r\n    \"components\": {\r\n      \"minecraft:icon\": \"byh:item\" // 物品贴图ID\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\n接着在资源包根目录新建一个“textures”文件夹，在里面接着创建一个“item_texture.json”文件\r\n```json\r\n{\r\n  \"resource_pack_name\": \"vanilla\",\r\n  \"texture_name\": \"atlas.items\",\r\n  \"texture_data\": {\r\n    \"byh:item\": { //对应物品贴图名字\r\n      \"textures\": \"textures/items/byh:item\"  //贴图位置，起始目录为资源包根目录\r\n    }\r\n  }\r\n}   \r\n\r\n```\r\n\r\n\r\n资源包根目录创建一个“texts”文件夹，这个是语言文件夹\r\n接着再新建一个文件，名字“zh_CN.lang”\r\n\r\n这个表示中文简体语言，繁体则是“zh_TW”，英语(美)“en_US”\r\n其它语言文件也是同理。\r\n\r\n\r\n``item.byh:item.name=测试物品``\r\n\r\n\r\n\r\n格式：item.命名空间:ID.name=显示的文字\n**<font color=\"#FF0000\">注意大小写</font>**","title":"3-1.自定义物品"},{"path":"3-2.自定义方块.md","content":"### 行为包\r\n首先在行为包目录创建“blocks”文件夹，接着在里面新建json文件（文件名字随意）\r\n```json\r\n{\r\n \"format_version\": \"1.16.200\",\r\n \"minecraft:block\": {\r\n   \"description\": {\r\n     \"identifier\": \"byh:block\",  \r\n     \"register_to_creative_menu\": true,  \r\n     \"is_experimental\": false\r\n   },\r\n   \"components\": {}  \r\n }\r\n}\r\n```\r\n#### 解释：\n##### format_version\n格式版本\n##### minecraft:item\n定义方块的各个模块，基础信息、组件等\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| description | 方块基础信息 | 对象 | null | |\n| components | 组件 | 对象 | null | |\n###### description\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| identifier | 方块唯一标识符 | 字符串 | null | 命名空间:ID |\n| register_to_creative_menu | 注册到创造物品栏。PS:1.16已废。 | 布尔 | true | true或false |\n| is_experimental | 需要开启实验玩法才能注册 | 布尔 | false | true或false |\r\n\r\n\r\n\r\n### 资源包\n#### 贴图与语言\n\r\n在资源包根目录新建一个\"blocks.json\"文件。\r\n```json\r\n{\r\n  \"format_version\": [1,16,0],\r\n  \"byh:block \": {  //命名空间:ID\r\n    \"textures\": \"byh:block\",  //方块的图标名字\r\n    \"sound\": \"stone\"  //方块的音效，可直接调用原版也可以自定义音效。\r\n  }\r\n}  \r\n```\r\n该文件用于定义方块的图标与音效。\r\n\r\n然后在 资源包根目录/textures/ 文件夹里新建\"terrain_texture.json\"文件\r\n```json\r\n{\r\n  \"resource_pack_name\": \"vanilla\",\r\n  \"texture_name\": \"atlas.terrain\",\r\n  \"padding\": 5,\r\n  \"num_mip_levels\": 4,\r\n  \"texture_data\": {\r\n    \"byh:block\": {  //图标名字\r\n      \"textures\": \"textures/blocks/byh:block\"  //贴图路径\r\n    }\r\n  }\r\n}    \r\n```\r\n\r\n**语言**\r\n``tile.byh:block.name=测试方块``\r\n格式：tile.命名空间:ID.name=显示文字","title":"3-2.自定义方块"},{"path":"3-3.自定义配方.md","content":"### **本节目录**\n##### 3-3.自定义配方\r\n###### 3-3-1.自定义合成\r\n###### 3-3-2.自定义熔炼\r\n###### 3-3-3.自定义切石机\r\n###### 3-3-4.自定义酿造台\r\n###### 3-3-5.自定义制图台\n\n**自定义配方**并非**仅指**工作台合成配方，我把配方类型一共分为了五类：\r\n1.自定义合成（工作台或背包里合成）\r\n2.自定义熔炼（熔炉/高炉/烟熏炉/篝火）\r\n3.自定义切石机配方\r\n4.自定义酿造台配方\r\n5.自定义制图台配方\r\n\r\n首先在行为包根目录创建一个\"recipes\"文件夹，所有类型的配方都将放在该文件夹里或该文件夹的子文件夹里。","title":"3-3.自定义配方"},{"path":"3-3-1.自定义合成.md","content":"在**recipes**文件夹里新建一个JSON文件，名字随意。\r\n\r\n配方分为**无序合成**与**有序合成**\r\n**有何区别？**\r\n无序合成：只要在合成栏有设定好的物品（不能多也不能少一个多余的物品）即可合成出。\r\n有序物品：在合成栏里的位置,数量都必须与设定里的一样才能合成。\r\n\r\n#### 无序合成\r\n```json\r\n{\r\n  \"format_version\": \"1.16\",\r\n  \"minecraft:recipe_shapeless\": {\r\n    \"description\": {\r\n    \"identifier\": \"byh:g1\"  //该配方的 命名空间:ID\r\n    },    \r\n    \"tags\": [ \"crafting_table\" ],  //配方类型：工作台\r\n    \"ingredients\": [\r\n      {\r\n        \"item\": \" \",  //物品ID，必选值\r\n        \"data\": 0,  //物品特殊值，可选值\r\n        \"count\": 1  /物品数量 ，可选值\r\n      },\r\n      {\r\n        \"item\": \"\" \r\n      }\r\n    ],\r\n    \"result\": {\r\n      \"item\": \"\"   //合成出来的结果\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### 有序合成\r\n```json\r\n{\r\n  \"format_version\": \"1.16\",\r\n  \"minecraft:recipe_shaped\": {\r\n    \"description\": {\r\n      \"identifier\": \"byh:g2\"  \r\n    },\r\n\r\n\r\n    \"tags\": [ \"crafting_table\" ],\r\n    \"pattern\": [  //图表\r\n      \"aaa\",\r\n      \"aba\",\r\n      \"aaa\"  //图表的规格随意,但最大只能3x3,里面的每个字母都对应一个物品，如果该位置是空气就直接用空格表示。\r\n    ],\r\n    \"key\": {\r\n      \"a\": {  //对照上面\r\n        \"item\": \" \"  //物品1\r\n      },\r\n      \"b\"{  //对照上面\r\n        \"item\": \" \"  //物品2\r\n      }\r\n    },\r\n    \"result\": {\r\n      \"item\": \" \"  //结果\r\n    }\r\n  }\r\n}\r\n```","title":"3-3-1.自定义合成"},{"path":"3-3-2.自定义熔炼.md","content":"熔炼有四种不同方式：熔炉,高炉,烟熏炉,篝火\r\n\r\n在**recipes**文件夹里新建一个JSON文件，名字随意。\r\n\r\n```json\r\n{\r\n  \"format_version\": \"1.16\",\r\n  \"minecraft:recipe_furnace\": {\r\n    \"description\": {\r\n    \"identifier\": \" \"\r\n    },\r\n    \"tags\": [\"furnace\"],  //类型：熔炉，也可以是高炉,烟熏炉,篝火(因为这都是同一属性的)\r\n    \"input\": \" \",  //输入物品\r\n    \"output\": \" \"  //输出物品\r\n  }\r\n}\r\n```\r\n\r\n**furnace**\r\n使用熔炉合成配方\r\n\r\n熔炉（Furnace）是一种用来烧炼方块和物品并把它们转换为另一种方块或物品的方块。\r\n\r\n**blast_furnace**\r\n使用高炉合成配方\r\n\r\n高炉（Blast Furnace）是与熔炉和烟熏炉相似的方块实体，专用于烧炼矿石、盔甲和工具。\r\n\r\n**smoker**\r\n使用烟熏炉合成配方\r\n\r\n烟熏炉（Smoker）是屠夫村民的工作站点方块，是专门用于烹制熟食的熔炉变种。\r\n\r\n**campfire**\r\n使用篝火合成配方\r\n\r\n篝火（Campfire） 是一种可用于烹饪食物并作为光源或烟雾信号使用的方块。","title":"3-3-2.自定义熔炼"},{"path":"3-3-3.自定义切石机.md","content":"还是在**recipes**文件夹里新建一个JSON文件，名字随意。\r\n\r\n```json\r\n{\r\n  \"format_version\": \"1.16\",\r\n  \"minecraft:recipe_shapeless\": {\r\n    \"description\": {\r\n        \"identifier\": \" \"\r\n        },\r\n        \"tags\": [ \"stonecutter\" ],  //类型：切石机\r\n        \"priority\": 1,  //在切石机可合成界面里的位置,1最靠前面\r\n        \"ingredients\": [\r\n         {\r\n            \"item\": \" \"  //输入物品\r\n          }\r\n        ],\r\n        \"result\": {\r\n          \"item\": \" \"  //结果\r\n        }\r\n  \t}\r\n}\r\n```","title":"3-3-3.自定义切石机"},{"path":"3-3-4.自定义酿造台.md","content":"依然是在**recipes**文件夹里新建一个JSON文件，名字随意。\r\n\r\n```json\r\n{\r\n  \"format_version\": \"1.12\",\r\n  \"minecraft:recipe_brewing_container\": {\r\n    \"description\": {\r\n      \"identifier\": \" \"\r\n    },\r\n\r\n    \"tags\": [ \"brewing_stand\" ],  //类型：酿造台\r\n\r\n    \"input\": \" \",  //输入物品1，此处原版默认为水瓶\r\n    \"reagent\": \" \",  //输入物品2\r\n    \"output\": \"  \"  //结果\r\n  }\r\n\r\n}\r\n```","title":"3-3-4.自定义酿造台"},{"path":"3-3-5.自定义制图台.md","content":"最不常用的一个自定义配方。\r\n```\r\n{\r\n  \"format_version\": \"1.12\",\r\n  \"minecraft:recipe_shapeless\": {\r\n    \"description\": {\r\n    \"identifier\": \" \"\r\n    },\r\n    \"tags\": [ \"cartography_table\" ],  //类型：制图台\r\n    \"ingredients\": [\r\n      {\r\n        \"item\": \" \"  //输入物品1，放在制图台上面的格子\r\n      },\r\n      {\r\n        \"item\": \" \"  //输入物品2，放在下面的各种\r\n      }\r\n    ],\r\n    \"result\": {\r\n      \"item\": \" \"  //结果\r\n    }\r\n  }\r\n}\r\n```","title":"3-3-5.自定义制图台"},{"path":"3-4.自定义生成结构.md","content":"### 本节目录\n##### 3-4.自定义生成结构\r\n###### 3-4-1.自定义生物群系\r\n###### 3-4-2.自定义树特征\r\n###### 3-4-3.自定义矿石特征\r\n###### 3-4-4.自定义结构特征\n","title":"3-4.自定义生成结构"},{"path":"3-4-1.自定义生物群系.md","content":"","title":"3-4-1.自定义生物群系"},{"path":"3-4-2.自定义树特征.md","content":"","title":"3-4-2.自定义树特征"},{"path":"3-4-3.自定义矿石特征.md","content":"","title":"3-4-3.自定义矿石特征"},{"path":"3-4-4.自定义结构特征.md","content":"","title":"3-4-4.自定义结构特征"},{"path":"3-5.自定义实体.md","content":"### 本节目录\n##### 3-5.自定义实体\r\n###### 3-5-1.组成结构\r\n###### 3-5-2.行为包部分-实体行为(必选)\r\n###### 3-5-3.行为包部分-实体生成(可选)\r\n###### 3-5-4.行为包部分-实体掉落物(可选)\r\n###### 3-5-5.资源包部分-实体资源包定义(必选)\r\n###### 3-5-6.资源包部分-材质(可选)\r\n###### 3-5-7.资源包部分-模型(可选)\r\n###### 3-5-8.资源包部分-贴图(可选)\r\n###### 3-5-9.动画\r\n###### 3-5-10.动画控制器\r\n###### 3-5-11.资源包部分-渲染控制器(可选)\n恭喜你！你终于来到了Addon最精华的部分——实体！\r\n至于为何是精华，在接下来的篇章中将会一一讲到。\r\n\r\n**实体**一共分为**两大类**,生物与特殊实体(个人理解)\r\n生物又分为**三大类**，被动型、中立型、敌对型\r\n特殊实体包括投掷物以及一些作用非常特殊的实体。","title":"3-5.自定义实体"},{"path":"3-5-1.组成结构.md","content":"**实体**会涉及到：\r\n**资源包**：实体资源包实体（entity）、材料（material）、贴图（texture）、模型（model）、动画（animation）、动画控制器（animation controller）、渲染控制器（render controller）、音乐与音效（sound）、颗粒效果（particles）等\r\n**行为包**：实体行为定义（entities）、动画（animation）、动画控制器（animation controller）、战利品掉落物（loot_tables）、实体生成（spawn_rules）、交易列表（trading）、脚本（scripts）等\n*****\n\r\n\r\n此时你的心理：WDF？？？这都是些什么玩意儿？？我还是个萌新啊！\r\n\r\n不用慌，这只是可涉及到范围，无需全用上。一个实体，必要的文件只需要一个**实体行为定义**文件，资源包无需任何其它文件！\r\n如果是做一个**看得见**的实体 资源包则需要 实体资源包定义、渲染控制器、模型、贴图、材质即可。\r\n\r\n如果要做一个**完整**的实体（这里的”完整“以原版猪、牛、僵尸一类的生物为准）则需要：\r\n**行为包：**实体行为定义、实体生成、实体战利品掉落物\r\n**资源包：**实体资源包定义、动画、动画控制器、渲染控制器、材料、模型、贴图、音效\r\n\r\n","title":"3-5-1.组成结构"},{"path":"3-5-2.行为包部分-实体行为必选.md","content":"\r\n**实体行为**可谓是精华的核心部分，首先你需要对实体行为的运行方式有一个大概了解\r\n\r\n![实体各部分关联示意图](https://pic.downk.cc/item/5f301be214195aa594ee3cfb.png)\r\n**实体行为**共分为三大部分：**组件、组件组、事件**\r\n\r\n\r\n#### 组件\r\n实体组件分为四大类：固有属性组件（如碰撞箱子）、行为组件（如近战、看着玩家、自由走动）、触发器、其它\r\n\r\n\r\n**触发器**被游戏调用后如果满足滤器要求将触发事件\r\n详情见 **4-6**\n\r\n\r\n#### 事件\r\n事件用于添加与删除组件组，此外，游戏也保留了一些事件，这些事件无需被触发器调用，在指定条件下就会触发（如：minecraft:entity_spawn事件在实体生成时触发）\r\n详情见 **4-6**\r\n\r\n\r\n#### 组件组\r\n分组区，每个组件组都将会存放组件，这些组件组在指定条件下会被启用或者禁用\r\n组件组将会给予生物额外的属性或者行为（组件组普遍性用处，也有些时候是用来触发动画控制器）\n\n相关接口请查阅AddonAPI文档\n\r\n\r\n### 总结：\r\n**组件定义实体属性与行为，触发器将会在指定条件下触发事件，事件将会添加或删除对应组件组，组件组将会给予生物额外的属性或者行为**\n实例，为原版猪行为，已删减不必要部分\n```json\n{\r\n  \"format_version\": \"1.13.0\",  //版本\r\n  \"minecraft:entity\": {\r\n    \"description\": {\r\n      \"identifier\": \"minecraft:pig\",  //命名空间:ID\r\n      \"is_spawnable\": true,  //会有生物蛋\r\n      \"is_summonable\": true,  /能被/summon指令生成\r\n      \"is_experimental\": false  //需要实验玩法\r\n    },\r\n\r\n    \"component_groups\": {  //组件组区\r\n\r\n      \"minecraft:pig_baby\": {  //一个组件组，这个组件组定义幼年猪特有组件，如：碰撞箱会变小、无法繁殖。\r\n        \"minecraft:is_baby\": {\r\n        },\r\n        \"minecraft:scale\": {\r\n          \"value\": 0.5\r\n        },\r\n\r\n        \"minecraft:behavior.follow_parent\": {\r\n          \"priority\": 6,\r\n          \"speed_multiplier\": 1.1\r\n        }\r\n      },\r\n\r\n\r\n      \"minecraft:pig_adult\": {  //定义成年猪特有组件，如：会有战利品掉落、可以繁殖。\r\n        \"minecraft:experience_reward\": {\r\n          \"on_bred\": \"Math.Random(1,7)\",\r\n          \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"\r\n        },\r\n        \"minecraft:loot\": {\r\n          \"table\": \"loot_tables/entities/pig.json\"\r\n        },\r\n        \"minecraft:behavior.breed\": {\r\n          \"priority\": 4,\r\n          \"speed_multiplier\": 1.0\r\n        },\r\n          \"breed_items\": [ \"carrot\", \"beetroot\", \"potato\" ]\r\n        }\r\n      }\r\n    },\r\n\r\n\r\n    \"components\": {  //组件区，即幼年猪与成年猪都拥有的组件\r\n      \"minecraft:behavior.panic\": {\r\n        \"priority\": 3,\r\n        \"speed_multiplier\": 1.25\r\n      },\r\n      \"minecraft:behavior.random_stroll\": {\r\n        \"priority\": 7,\r\n        \"speed_multiplier\": 1.0\r\n      },\r\n      \"minecraft:behavior.look_at_player\": {\r\n        \"priority\": 8,\r\n        \"look_distance\": 6.0,\r\n        \"probability\": 0.02\r\n      },\r\n      \"minecraft:behavior.random_look_around\": {\r\n        \"priority\": 9\r\n      },\r\n\t    \"minecraft:physics\": {\r\n      },\r\n      \"minecraft:pushable\": {\r\n        \"is_pushable\": true,\r\n        \"is_pushable_by_piston\": true\r\n      }\r\n    }, \r\n\r\n\r\n    \"events\": {  //事件\r\n      \"minecraft:entity_spawned\": {  //游戏自带的事件，在该实体生成时触发\r\n        \"randomize\": [\r\n          {  //结果1\r\n            \"weight\": 95,  //几率：95%，百分比\r\n            \"remove\": {\r\n            },\r\n            \"add\": {  //如果是，则添加成年猪组件组\r\n              \"component_groups\": [\r\n                \"minecraft:pig_adult\"\r\n              ]\r\n            }\r\n          },\r\n          {\r\n            \"weight\": 5,  //几率：5%\r\n            \"remove\": {\r\n            },\r\n            \"add\": {  //如果是，则添加幼年猪组件组\r\n              \"component_groups\": [\r\n                \"minecraft:pig_baby\"\r\n              ]\r\n\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\n```\n#### 解释\n##### format_version\n格式版本\n##### minecraft:entity\n###### description\n描述了实体的基本信息\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| identifier | 实体命名空间:ID | 字符串 | null | 所有字符 |\n| is_spawnable  | 实体是否有生物蛋 | 布尔 | true | true或false |\n| is_summonable | 实体是否能被/summon指令生成 | 布尔 | true | true或false |\n| is_experimental | 是否需要实验玩法 | 布尔 | false | true或false |\n| runtime_identifier ||||||\n| scripts | 脚本 | 对象 | null | 对象 |\n| animations | 用于给实体绑定动画/动画控制器(服务端) | 对象| null | 对象 |\n**scripts**\n这里不指Script Engine脚本引擎，而是指Molang表达式\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| animate | 用于模仿原始实体的硬编码元素，它接受Minecraft原版中的标识符 | 字符串 | null | 所有字符 |\n栗子：\n```json\n  \"minecraft:entity\": {    \r\n    \"description\": {\r\n      \"identifier\": \"minecraft:player\",\r\n      \"is_spawnable\": false,\r\n      \"is_summonable\": true,\r\n      \"is_experimental\": false,\n      \"runtime_identifier\": \"minecraft:shulker\",\r\n      \"scripts\": {\r\n        \"animate\": [\r\n          \"byh1\",\n          \"byh2\"\n\r\n        ]\r\n      },\r\n      \"animations\": {\r\n        \"byh1\": \"animation.byh1\" //绑定动画（服务端），且在实体生成时会立刻调用一次（此处键要与animate中的一致）\r\n        \"byh2\": \"controller.animation.byh2\" //绑定动画控制器（服务端），且在实体生成时会立刻调用一次\r\n      }\r\n    },\n```","title":"3-5-2.行为包部分-实体行为(必选)"},{"path":"3-5-3.行为包部分-实体生成可选.md","content":"写完一个实体**行为定义**后往往是不够的，若想让这个生物能够自然生成还需要写一下**实体生成定义**(spawn_rules)\r\n\r\n首先在行为包根目录新建**spawn_rules**文件夹\r\n接着在该文件夹（或该文件夹的子文件夹里）创建 实体ID.json 文件\r\n\r\n栗子：\r\n```json\r\n{\r\n  \"format_version\": \"1.8.0\",\r\n  \"minecraft:spawn_rules\": {\r\n    \"description\": {\r\n      \"identifier\": \" \",  //实体 命名空间:ID 用于绑定对应实体\r\n      \"population_control\": \"animal\"  //种群控制：动物，也可选：monster（怪物）\r\n    },\r\n    \"conditions\": [  //生成条件\r\n      {\r\n        \"minecraft:spawns_on_block_filter\": \"minecraft:grass\",  //在什么方块上生成\r\n        \"minecraft:brightness_filter\": {  //在什么亮度下生成\r\n          \"min\": 7,  //最小\r\n          \"max\": 15,  //最大\r\n          \"adjust_for_weather\": false  //根据天气所变换？ 否\r\n        },\r\n        \"minecraft:herd\": {  //每次生成数量\r\n          \"min_size\":2,  //最小\r\n          \"max_size\":3  //最大\r\n        },\r\n    \r\n        \"minecraft:biome_filter\": {  //生物群系，PS:这是一个滤器\r\n          \"test\": \"has_biome_tag\", \"operator\":\"==\", \"value\": \"animal\"\r\n        }  //测试项目：生物群系标签，测试方式：等于（或一致的意思），值：animal。将会在带有animal标签的生物群系里生成。 \r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n更多实体生成条件请参考MinecraftWiki的官方文档\n具体内容参考文章\r\n","title":"3-5-3.行为包部分-实体生成(可选)"},{"path":"3-5-4.行为包部分-实体掉落物可选.md","content":"战利品掉落将会在实体被玩家打死后触发，至于是否会掉落就得看设定的几率了。\r\n\r\n战利品掉落绑定对应实体的方式与实体生成不同\r\n实体生成是实体生成去绑定实体行为定义\r\n实体掉落物则是实体行为定义去绑定战利品掉落物\r\n\r\n首先给实体添加一个组件：\r\n```json\r\n\"minecraft:loot\": {  //战利品掉落\r\n  \"tables\": \"loot_tables/entity/xx.json\"  //战利品掉落物定义文件路径\r\n}\r\n```\r\n\r\n其实战利品掉落物文件不一定要在lott_tables文件夹，但我们这依然按照传统惯例\r\n**<font color=\"#FF0000\">注意:路径最后JSON名字后面还需加上后缀名“.json”</font>**\r\n\r\n\n具体内容参考文章","title":"3-5-4.行为包部分-实体掉落物(可选)"},{"path":"3-5-5.资源包部分-实体资源包定义必选.md","content":"entities实体行为定义为实体在行为包里的**核心部分**，也是实体在整个Addon里的**核心部分**\r\n\r\nentity实体资源包定义则是**资源包**的**核心部分**，但是资源包部分为**可选**，当一旦选择了资源包部分，那么**实体资源包定义**将会是必须项。\r\n\r\n#### 作用\r\n**实体资源包定义**将会控制该实体的 材质、模型、贴图、动画、动画控制器、渲染控制器、生物蛋以及Molang脚本。 \r\n**对于**贴图起引导图片路径的作用\r\n**对于**材料、模型、动画、动画控制器、渲染控制器起绑定对应项目的作用\r\n**对于**生物蛋、脚本起定义的作用\r\n\r\n#### 开始\r\n首先在资源包根目录创建一个“entity”文件夹\r\n再在该文件夹（或该文件夹的子文件夹里）**创建** 实体ID.json 文件\r\n\r\n下面则是一个僵尸的栗子：\r\n```json\r\n//已删减不必要内容，已添加注释\r\n{\r\n  \"format_version\": \"1.8.0\",\r\n  \"minecraft:client_entity\": {\r\n    \"description\": {\r\n      \"identifier\": \"minecraft:zombie\",  //命名空间:ID，需要与行为包entities里的文件吻合。\r\n      \"materials\": {\r\n        \"default\": \"zombie\"  //材料\r\n      },\r\n      \"textures\": {  //贴图\r\n        \"default\": \"textures/entity/zombie/zombie\"  //最后的图片名字无需后缀.png\r\n      },\r\n      \"geometry\": {  //模型\r\n        \"default\": \"geometry.zombie.v1.8\"\r\n      },\r\n      \"spawn_egg\": {  //生物蛋\r\n        \"texture\": \"spawn_egg\",\r\n        \"texture_index\": 12\r\n      },\r\n      \"scripts\": {  //脚本\r\n        \"pre_animation\": [\r\n          \"variable.tcos0 = (Math.cos(query.modified_distance_moved * 38.17) * query.modified_move_speed / variable.gliding_speed_value) * 57.3;\"\r\n        ]\r\n      },\r\n      \"animations\": {  //动画（客户端）\r\n        \"humanoid_big_head\": \"animation.humanoid.big_head\"\r\n           .....\r\n      },\r\n      \"animation_controllers\": [  //动画控制器（客户端）\r\n        { \"humanoid_baby_big_head\": \"controller.animation.humanoid.baby_big_head\" }\r\n          .....\r\n      \"render_controllers\": [ \"controller.render.zombie\" ]  //渲染控制器\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### 生物蛋\r\n**<font color=\"#FF0000\">首先你需要在行为定义把生物蛋生成 属性打开</font>**\r\n接着是实体资源包定义：\r\n官方一共给了两种写法\r\n\r\n首先是定义方法1：\r\n```\r\n\t\"spawn_egg\": {\r\n\t\t\"base_color\": \"#99e550\",  //基础颜色\r\n\t\t\"overlay_color\": \"#99e550\"  //套印颜色\r\n  }\r\n```\r\n使用官方提供的配色方案\r\n值类型为字符串，用十六进制颜色表达。\r\n\r\n然后是定义方法2：\n\r\n\r\n      \"spawn_egg\": {  //生物蛋\r\n        \"texture\": \"spawn_egg\",  //生物蛋ID,建议写成 实体ID_egg \r\n        \"texture_index\": 0  //只允许为正整数\r\n      }\n\r\n\r\n\r\n然后在textures/item_texture.json 文件里来控制生物蛋贴图位置\r\n\r\n    \"spawn_egg\": {  //生物蛋ID\r\n      \"textures\": \"textures/items/spawn\"  //贴图路径\r\n    }\r\n\r\n与物品贴图定义一致。\r\n\r\n\r\n#### 命名\r\n**生物命名**\r\n接着是在texts文件夹对生物进行命名\r\n\r\n```\r\nentity.byh:entity.name=测试生物\r\n```\r\n\r\n格式:\r\nentity:命名空间:ID.name=名字\r\n\r\n**生物蛋命名**\r\n\r\n```\r\nitem.spawn_egg.entity.byh:entity.name=生成测试生物\r\n```\r\n\r\n格式：\r\nitem.spawn_egg.entity.命名空间:ID.name=名字","title":"3-5-5.资源包部分-实体资源包定义(必选)"},{"path":"3-5-6.资源包部分-材料可选.md","content":"**materials**将决定生物是否透明与发光等属性\r\n\r\n首先在资源包根目录新建**materials**文件夹，接着在该文件夹里新建**entity.material**文件\r\n没错！这个文件的**后缀**将不再是.json！\r\n\r\n依然以文本编辑方式打开。\r\n\r\n```\r\n    \"byh:entity\": {},\r\n```\r\n\r\n引号里的为实体 命名空间:ID，花括号{ }里的则是属性定义，如果不写任何东西将会是默认形式。\n\n具体内容参考文章","title":"3-5-6.资源包部分-材料(可选)"},{"path":"3-5-7.资源包部分-模型可选.md","content":"#### 软件安装与配置\r\n**1.**首先下载**Blockbench**软件，下载完后双击exe程序安装。\r\n**2.**等待安装完毕，接着打开Blockbench。\r\n**3.**第一次打开后，界面会是英文。点击左上角的“file”，然后选择“Settings”\r\n![1](https://pic.downk.cc/item/5f31061214195aa59425ebbf.png)\r\n\r\n**4.**打开后的界面第一个选项就是语言设置，点它\r\n![2](https://pic.downk.cc/item/5f31061214195aa59425ebc3.png)\r\n然后切换到“中文（chinese）”\r\n![3](https://pic.downk.cc/item/5f31061214195aa59425ebc5.png)\r\n\r\n**5.**切换后，选择下面的close，接着重进Blockbench\r\n\r\n#### 开始制作\r\n![新建](https://pic.downk.cc/item/5f31102c14195aa59429a942.png)\r\n新建一个基岩版模型,文件名字与模型名字都推荐为 实体ID.json的格式。\r\n\r\n![模式](https://pic.downk.cc/item/5f310f8c14195aa594296da9.png)\r\n**Blockbench**一共有三种模式：编辑模式、画板模式、动画模式\r\n本次讲的编辑模式。\r\n\r\n**首先熟悉一下操作界面**\r\n![界面](https://pic.downk.cc/item/5f310f8c14195aa594296dab.png)\r\n上面的为工具栏，存放移动/旋转/尺寸等工具\r\n左边为贴图区\r\n右边为块\r\n中间则是一个可视化编辑\r\n\r\n![制作开始](https://pic.downk.cc/item/5f3111f014195aa5942a4c87.png)\r\n在右边进行添加一个块，用移动工具将块移动到你想要的位置，接着使用尺寸工具编辑长度与大小。\r\n也可以将块进行旋转等。\r\n\r\n你只需要尽情的发挥你的想象力！\r\n\r\n#### 导出\r\n制作完成后，我们要导出模型。\r\n![导出](https://pic.downk.cc/item/5f310f8c14195aa594296daf.png)\r\n但需要注意一点，不要直接选择“保存工程”\r\n而是要选择 导出 > 导出基岩版几何体\r\n\r\n![保存](https://pic.downk.cc/item/5f310f8c14195aa594296db3.png)\r\n接着保存到**资源包**根目录/models/entity 文件夹里\r\n**<font color=\"#FF00000\">注意：不能保存到/models/entity 文件夹的子文件夹里！</font>**\n\n模型与贴图一样都需要耐心\n如若跟我一样建模建得稀烂，像素画画得像坨屎可以花钱找模型师与画师帮你制作","title":"3-5-7.资源包部分-模型(可选)"},{"path":"3-5-8.资源包部分-贴图可选.md","content":"将**Blockbench**切换到**画板模式**\r\n然后在左下角新建或导入贴图\r\n贴图大小传统格式：\r\n16x16\r\n16x32\r\n32x32\r\n32x64\r\n64x64\r\n64x128\r\n128x128\r\n...\r\n1024x1024\n比例大多为1:1或1:2\n\r\n\r\n制作完成后在左下角保存贴图到**实体资源包定义**里对应的路径即可。\r\n![保存贴图](https://pic.downk.cc/item/5f31155414195aa5942b81af.png)","title":"3-5-8.资源包部分-贴图(可选)"},{"path":"3-5-9.动画.md","content":"动画分为**客户端**与**服务端**\r\n客户端即**资源包**，服务端则是**行为包**\r\n\r\n**服务端**不会存在任何视觉效果，用于制作一些逻辑，可以为Molang表达式、指令、事件等。\r\n\r\n**客户端**则专门负责视觉上的效果，客户端的动画才为普遍意义上的”动画“，控制生物骨骼模型的变化。\r\n\r\n本章节讲的为**客户端**动画，**服务端**动画请参考 专辑篇\r\n\r\n**动画**被规定为短名称，后可跟其完整的资源名称。该短名称能用于**动画控制器**和scripts/animate列表，其后的完整名称用于动画文件。\r\n\r\n在scripts/animate部分，你需要列出播放的动画以及播放顺序。你能直接指定动画，也能指定混合表达式（blend expression）\r\n\r\n将**Blockbench**切换到**动画模式**即可进行可视化的编辑，制作完毕你需要将动画保存至**资源包**根目录/animations 文件夹里（或该文件夹的子文件夹里）\n*****\n关于动画与动画控制器具体内容参考 请参考 4-2","title":"3-5-9.动画"},{"path":"3-5-10.动画控制器.md","content":"动画控制器也分为**客户端**与**服务端**\r\n客户端即**资源包**，服务端则是**行为包**\r\n\r\n**服务端**不会存在任何视觉效果，用于制作一些逻辑，可以为Molang表达式、指令、事件等。\r\n\r\n本章节讲的为**客户端**动画，**服务端**动画请参考 专辑篇\r\n\r\n\r\n我们需要能够控制动画的播放方式、播放时间以及与其他动画的交互方式。 在实体定义“scripts”中管理大量动画的同时，对动画进行分组动画。","title":"3-5-10.动画控制器"},{"path":"3-5-11.资源包部分-渲染控制器可选.md","content":"在资源包根目录新建”**render_controllers**“文件夹\r\n接着在该文件夹里(或该文件夹的子文件夹里)进行**新建**一个 实体ID.json文件。\r\n\r\n以下为一个渲染控制器的示例：\r\n```json\r\n{\r\n  \"format_version\": \"1.8.0\",\r\n  \"render_controllers\": {\r\n    \"controller.render.shengwu\": {  //渲染控制器的ID，格式必须为controller.render.XXXXX\r\n      \"geometry\": \"Geometry.default\",  \r\n      \"materials\": [ { \"*\": \"Material.default\" } ],\r\n      \"textures\": [ \"Texture.default\" ]\r\n    }\r\n  }\r\n}\r\n\r\n```\n具体内容参考文章","title":"3-5-11.资源包部分-渲染控制器(可选)"},{"path":"3-6.自定义颗粒效果.md","content":"粒子效果需适用/particle进行生成\n首先，在资源包根目录新建particles文件夹，接着在该文件夹或其子文件夹内新建 粒子ID.json 文件\n栗子：\n~~~\n{\n  \"format_version\": \"1.16.0\",\n  \"particle_effect\": {\n    \"description\": {\n      \"identifier\": \"byh:pa\", \n      \"basic_render_parameters\": {\n          \"material\": \"\"\n          \"texture\": \"\"\n      }\n    },\n    \"curves\": {\n    },\n    \"components\": \n      // 有关粒子生成频率的组件\n\n      // 有关粒子生成时长的组件\n\n      // 有关粒子生成形状（或通过粒子粒子生成位置和方向定义其形状）的组件\n\n      // 粒子生成容器本地空间（local space）组件\n\n      // 控制粒子初始状态的组件\n\n      // 控制/引导粒子行为的组件\n\n      // 影响粒子渲染方式的组件\n\n      // 影响粒子效果时长的组件\n    }\n  }\n}\n~~~\n### 解释\n#### format_version\n格式版本\n#### particle_effect\n粒子效果\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| description | 基础信息 | 对象 | null | 对象 |\n| curves | 有关曲线的定义 | 对象 | null | 对象|\n| components | 组件 | 对象 | null | 对象 |\n##### description\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| identifier | 粒子效果命名空间:ID | 字符串 | null  | 所有字符 |\n| basic_render_parameters | 基本渲染参数 | 对象 | null | 对象 |\n###### basic_render_parameters\n| 键  | 描述 | 类型 | 默认值 | 可选值 |\n| --- | --- | --- | --- | --- |\n| material | 粒子效果使用的材料 | 字符串 | null | 所有字符 |\n| texture | 粒子效果贴图路径 | 字符串 | null | 所有字符 |","title":"3-6.自定义颗粒效果"},{"path":"3-7.自定义音乐与音效.md","content":"音乐可使用/playsound指令进行播放\n首先，在资源包根目录创建”sounds“文件夹，接着在该文件夹内新建sound_definitions.json文件\n接着，这样写↓\n```json\n{\r\n    \"format_version\": \"1.16.0\",\r\n    \"sound_definitions\": {\r\n        \"music1\": {  //此处键的名字决定playsound指令将填写的id\r\n            \"sounds\": [\r\n                {\r\n                    \"name\": \"sounds/byh/music1\",  //音频文件路径\r\n                    \"volume\": 1.0  //音量\r\n                }\r\n            ]\r\n        },\r\n        \"music2\": {  \r\n            \"sounds\": [\r\n                {\r\n                    \"name\": \"sounds/byh/music2\",  \r\n                    \"volume\": 1.0 \r\n                }\r\n            ]\r\n        }\r\n    }\r\n}\n```\n### 音频\n注意，MC只支持识别ogg音频文件与fsb特殊音频处理文件\nogg音频文件转换方法请自行[baidu.com](https://baidu.com)","title":"3-7.自定义音乐与音效"},{"path":"4.后期.md","content":"### 本章目录\n#### 4.后期篇\r\n###### 4-1.Addon加密\r\n###### 4-2.Addon发布\n在原博客的教程当中，还有一个专辑篇。但经改动后，将不算在本入门教程内，如若需要，请前往其它目录查看。\n","title":"4.后期"},{"path":"4-1.Addon加密.md","content":"提到**Addon加密**可谓是行内看笑话，行外看新鲜。\n对于JSON文件而言，所谓的“加密”只是对其英文与中文转换成Unicode编码形式，再进行压缩成一行，使看起来眼花缭乱。\n又或者是其它的障眼法。\n\n## Unicode\nUnicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的[二进制编码](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/1758517)，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。","title":"4-1.Addon加密"},{"path":"4-2.Addon发布.md","content":"## 打包\n将资源包与行为包都复制到同一目录下\n![](https://img.imgdb.cn/item/60137ce33ffa7d37b32da177.png)\n接着再将其一起压缩\n![](https://img.imgdb.cn/item/60137ce33ffa7d37b32da179.png)\n*****\n## 发布\n以下仅为个人推荐\n### 官方渠道\n#### MinecraftBE商店\n这个门槛较高，需要是Microsoft的合作商才可\n#### 网易我的世界开发者平台\n算是国内最大的资源平台了，您需要去网易开发者官网使用身份证、银行卡等信息注册开发者账号\n### 其它渠道\n#### 各大论坛\n国内国外的都可，如[MCBBS中文论坛](https://mcbbs.com)、[Minecraftforum](https://www.minecraftforum.net/)、[Minebbs](https://www.minebbs.com/)\n#### MCPEDL\n全网最大的基岩版资源平台，注册门槛较低\n [https://mcpedl.com](https://mcpedl.com)\n#### 贴吧\n#### 视频网站\n虽说是视频网站，但可以以视频的方式宣传你的作品。\n国内视频网站中相对而言，推荐[Bilibili](https://bilibili.com)\n外国网站则[Youtube](https://youtube.com)","title":"4-2.Addon发布"},{"path":"基础概念.md","content":"# 基础概念\n认识语言文件、命令函数以及结构文件，并初步了解组件、组件组、事件三大巨头","title":"基础概念"},{"path":"Lang语言.md","content":"# Lang语言\n.lang是Mojang对不同语言文字存放的文件的后缀名\nlang文件都放在资源包根目录/texts文件夹内，因此在lang是资源包部分\n\n## 作用\n如 定义某个物品的显示文字，可以在该物品行为文件的组件中的minecraft:display_name组件直接设置。但是，如果你要让这些文字更好的方便管理且支持多语言那么就可以用到lang文件。\n\n## 使用\n在texts文件夹的目录下，可以看到下列文件\n* bg_BG.lang\n* cs_CZ.lang\n* da_DK.lang\n* de_DE.lang\n* el_GR.lang\n* en_GB.lang\n* en_US.lang\n* en_ES.lang\n* es_MX.lang\n* fi_FI.lang\n* fr_CA.lang\n* fr_FR.lang\n* hu_HU.lang\n* id_ID.lang\n* it_IT.lang\n* ja_JP.lang\n* ko_KR.lang\n* nb_NO.lang\n* nl_NL.lang\n* pl_PL.lang\n* pt_PT.lang\n* ru_RU.lang\n* sk_SK.lang\n* sv_SE.lang\n* tr_TR.lang\n* uk_UA.lang\n* zh_CN.lang\n* zh_TW.lang\n* language_names.json\n* languages.json\n\n默认有29种不同语言，你无需知道所有文件对应着什么语言，只需了解下面几个常用的：\nzh_CN 中文（简体）\nzh_TW 中文（繁体）\nen_US 英语（美式） English(US)\nen_GB 英语（英式） English(UK)\n### 自定义语言\n刚才说到“默认有”，也就是说，这些语言可以自定义？\n是的，这就要看到texts文件夹中的两个json文件了\n**languages.json**\n```json\n[\n\"en_US\"\n\"en_GB\",\n\"de_DE\",\n\"es_ES\",\n\"es_MX\",\n\"fr_FR\",\n\"fr_CA\",\n\"it_IT\",\n\"ja_JP\",\n\"ko_KR\",\n\"pt_BR\",\n\"pt_PT\",\n\"ru_RU\",\n\"zh_CN\"\n\"zh_TW\",\n\"nl_NL\",\n\"bg_BG\",\n\"cs_CZ\",\n\"da_DK\",\n\"el_GR\",\n\"fi_FI\",\n\"hu_HU\",\n\"id_ID\",\n\"nb_NO\",\n\"pl_PL\",\n\"sk_SK\",\n\"sv_SE\",\n\"tr_TR\",\n\"uk_UA\"\n]\n```\n该文件是一个数组，定义了都有哪些语言，也可以继续增加。\n**language_names.json**\n```\n[\n  [ \"en_US\", \"English (US)\" ],\n  [ \"en_GB\", \"English (UK)\" ],\n  [ \"de_DE\", \"Deutsch (Deutschland)\" ],\n  [ \"es_ES\", \"Español (España)\" ],\n  [ \"es_MX\", \"Español (México)\" ],\n  [ \"fr_FR\", \"Français (France)\" ],\n  [ \"fr_CA\", \"Français (Canada)\" ],\n  [ \"it_IT\", \"Italiano (Italia)\" ],\n  [ \"ja_JP\", \"日本語 (日本)\" ],\n  [ \"ko_KR\", \"한국어 (대한민국)\" ],\n  [ \"pt_BR\", \"Português (Brasil)\" ],\n  [ \"pt_PT\", \"Português (Portugal)\" ],\n  [ \"ru_RU\", \"Русский (Россия)\"],\n  [ \"zh_CN\", \"简体中文\" ],\n  [ \"zh_TW\", \"繁體中文\" ],\n  [ \"nl_NL\", \"Nederlands (Nederland)\" ],\n  [ \"bg_BG\", \"Български (BG)\" ],\n  [ \"cs_CZ\", \"Čeština (Česká republika)\" ],\n  [ \"da_DK\", \"Dansk (DA)\" ],\n  [ \"el_GR\", \"Ελληνικά (Ελλάδα)\" ],\n  [ \"fi_FI\", \"Suomi (Suomi)\" ],\n  [ \"hu_HU\", \"Magyar (HU)\" ],\n  [ \"id_ID\", \"Bahasa Indonesia (Indonesia)\" ],\n  [ \"nb_NO\", \"Norsk bokmål (Norge)\" ],\n  [ \"pl_PL\", \"Polski (PL)\" ],\n  [ \"sk_SK\", \"Slovensky (SK)\" ],\n  [ \"sv_SE\", \"Svenska (Sverige)\" ],\n  [ \"tr_TR\", \"Türkçe (Türkiye)\" ],\n  [ \"uk_UA\", \"Українська (Україна)\" ]\n]\n```\n该文件定义游戏中“语言设置”界面中\"不同语言选项\"所显示的文字，而这些文字则不是在lang文件中所定义的了。\n（这句话可能有点绕）\n### 编写\n打开lang文件，可以清除的发现格式非常简单\n下面是一个标准的语言串\n`xxx.xxxx.name=xxxx`\n等号前面部分为需要定义文字的位置，其中第一段是该位置的类型（包括物品item、方块tile、实体entity、UI等）\n等号前面第二段为该位置在该类型中的标识符，对于物品、方块、实体而言就是命名空间:ID。\n第三段则是统一的.name\n等号后面的是文字内容\n#### 注释\n在lang文件中，只要在前面加上一个#井号即代表注释\n示例：\n```\nitem.byh:a.name=物品A\n# 给byh:a物品命名为“物品A”\n tile.byh:b.name=方块B\n# 给byh:b方块命名为“物品B”\nentity.byh:c.name=方块C\n# 给byh:c实体命名为“实体C”\n```\n除此之外，也可以不按照标准格式的语言串写，只要满足“xxx.name=xxx”的格式即可\n对于这一些，你可以再在地图中配合使用/tellraw与/titleraw指令让其显示装载的资源包中的lang文件内的文字内容，以达到多语言地图的效果。\n以上两指令0具体使用方法，已超出本文章范围，请参考[MinecraftWiki]()\n\n## 你知道吗\njson中直接定义文字与lang文件定义相比，json中直接定义是有一个优点的\n那就是json中可以使用\\n、\\u、\\t、\\\\、\\b等这些常用的转义字符“\\”，而lang文件则不行","title":"Lang语言"},{"path":"Function命令函数.md","content":"# Function命令函数\n对于指令玩家来说，可能都知道游戏中有/function这条指令，但是未必大部分指令玩家都知道该指令的用法与意义。\n其实，/function是调用行为包根目录的functions文件夹内的对应.mcfunction文件中的所有指令\n`/function <文件名字（无需后缀）>`\n\n## 函数\n接触过编程的都知道，大部分编程语言中都有“函数”这个内容\n（请区分这里说的是**计算机函数**而非“数学函数”）\n函数在编程中的作用大概就是指一段可以直接被另一段程序或代码引用的代码。\n调用函数并传入新的参数进去，接着预先写好的函数就会按照新的参数执行一遍函数内的代码。\n栗子：\n```js\nfunction fun (x) {\n    value = x + 3\n    return value\n}\nfun(2)\n\n/*\n这里是用的js语言举例，这部分内容有点超纲，只是让大家明白function命令函数的作用与意义。\nfun是该函数的名字，该函数需要一个参数，该参数需是一个实数。\nfun函数会将运算 参数 + 3的结果，并返回结果\n“fun(2)”是调用fun函数，并指定参数为2，即2 + 3，最终会返回5\n如若不传参将会运行错误\n*/\n```\n 换到Minecarft里，行为包里的.mcfunction文件是封装了一堆其它指令，/function调用行为包里的文件将会一次性执行完文件内的指令，当然，目前mc中的命令函数只是可被调用，无法做到传参。\n\n## 编写\n这是行为包部分的内容，首先在行为包根目录新建一个“functions”文件夹，接着可以在该文件夹的里面子文件夹里面创建“xxx.mcfunction”文件\n使用文本编辑器打开.mcfunction文件\n接着即可在里面随意的写入mc中的指令了\n\n### 格式与注释\n格式为一行一串指令，开头斜杆/为可要可不要，执行身份是以管理员身份。\n注释也与lang文件一样，使用#井号标注。\n实例：\n```\nsay Hello Players!\ngive @a diammon 64\nkill @a[tag!=GoodPlayer]\n# 我是注释\n```\n## 使用\n写好后，加载行为包进入存档。\n若a.mcfunction文件在functions文件夹的根目录\n那么只需输入`/function a`即可\n若b.mcfunction文件在非functions文件夹的根目录里，而是在子文件夹内，如在 行为包根目录/functions/cs/b.mcfunction\n那么需在文件名前面加上目录`/function cs/b`\n\n## 运用范围\n对于指令玩家而言，可以用来做一键指令\n但对于Addon开发者而言，可以结合动画或动画控制器以及实体行为做出许多复杂的内容\n","title":"Function命令函数"},{"path":"Structure结构.md","content":"# Structure结构\n## 结构方块\n说到结构，那么就必定要提到结构方块（Structure Block）了\n基岩版的结构方块一共有三个模式，与java版的相比，基岩版独占了一种模式\n### 3D导出模式\n将会把结构导出为obj模型，该模式属基岩版独占。\n### 保存模式\n将会把结构保存在地图数据中\n![](https://static.wikia.nocookie.net/minecraft_zh_gamepedia/images/d/d8/Structure_Block_Bedrock_ClassicUI_Load.png/revision/latest/scale-to-width-down/800?cb=20200623075912)\n### 加载模式\n加载已保存的结构\n\n## .mcstructure\n除了3D导出模式以外，保存模式也可以导出结构，保存模式所导出的文件才是结构文件，即.mcstructure文件\n.mcstructure文件是未压缩的[NBT文件](https://wiki.vg/NBT#Specification)。与所有的基岩版NBT文件一样，它们以低位字节序格式存储。不建议使用文本方式进行编辑该文件。\n\n### 使用\n可将结构文件放置到行为包根目录的structures文件夹中，或其子文件夹中。\n进入存档，可使用/structure指令生成行为包中的结构文件，/structure与/function指令性质一样，但要注意一点\n**structures**文件夹中的所有文件都被赋予了*mystructure*的命名空间。","title":"Structure结构"},{"path":"组件、组件组、事件.md","content":"# 组件、组件组、事件\n为何要三个概念一起讲呢？因为它们之间的关联非常的大。\n在1.16.100及更高版本里，物品、方块、实体行为都能使用组件、组件组、事件，但三者被运用最多的地方也还是实体行为了，本文章中也主要是讲实体上的，物品、方块方面的也基本上适用。\n*****\n## 组件\n即**components**，物品、方块、实体行为都会用到组件，对应的组件定义了物品、方块、实体对应的属性\n组件的数据格式主要分为两种，国际版的组件命名空间均为“minecraft”，网易的额外接口的命名空间则是“netease”\n```json\n\"components\": {\n    //第一种，对象格式，一般用该格式的组件都有多个要设置的键，如“minecraft:boos”血条组件\n    \"minecraft:com1\": {\n        “value2”: 1,\n        \"value2\": true\n        \"value3\": [\n            \"player\",\n            \"zombie\",\n            \"pig\"\n.        ]\n    },\n    //第二种，直接写值格式，运用该格式的组件如“minecraft:loot”掉落物组件\n    \"minecraft:com2\": \"阿哲\"\n    //以上组件名均是无效，仅用于示例\n}\n```\n组件列表请查看AddonAPI文档\n实体组件类型分为四大类：固有属性组件（如碰撞箱子）、行为组件（如近战、看着玩家、自由走动）、触发器、其它\n## 组件组\n即**component_groups**，可理解为里面有多个不同的components，组件堆的名字为自定义。组件组中的components默认不会被启用，需通过**事件**来控制\n格式示例：\n```json\n\"component_groups\"： {\n    \"组件组1\": {  //组件组名字，可中文\n        \"minecraft:com3\": {  //里面随意的写组件即可\n            \"are_you_fool\": false\n        }\n    },\n    \"组件组2\": {\n        \"minecraft:com3\": {\n            \"are_you_fool\": true\n        }\n    }\n}\n```\n\n## 事件\n即**events**，事件控制组件组的启用于禁用\n基础格式示例：\n```json\n\"events\": {\n    \"事件1\": {  //事件名，可中文\n        \"add\": {  //添加\n            \"component_groups\": [\n                \"组件组1\"  //组件组列表\n            ]\n        },\n        \"remove\": {  //删除\n            \"component_groups\": [,\n                \"组件组2\",\n                \"组件组3\"\n            ]\n        }\n    },\n    \"事件2\": {\n        \"add\": {  \n            \"component_groups\": [\n                \"组件组1\",\n                \"组件组2\",\n                \"组件组3\"\n            ]\n        }\n    }\n}\n```\n事件分为被动事件与主动事件，主动事件是游戏中已被注册的几个事件名，数量不多，主动事件无需被触发才可执行，会自动在满足该事件要求下执行，如”minecraft:spawn“事件，会在该实体被生成时立刻执行。\n被动事件需要components或component_groups中的组件进行触发。\n以上为最基础的事件，事件还有许多带有逻辑的运用方式，这些请参考”专辑篇“\n*****\n三者集合起来可以做到许许多多的逻辑，组件中还有触发器等一些列内容，比如：先由components中的触发器触发一个事件，事件为其添加组件组，组件组又有新的触发器规则来触发事件添加/删除组件组，就这样循环，便可做出很多有意思的东西。","title":"组件、组件组、事件"},{"path":"名词解释.md","content":"# 名词解释\n各类专业名词的解释","title":"名词解释"},{"path":"标识符.md","content":"# 标识符\n**标识符**（identifier）是指用来标识某个实体的一个符号，在不同的应用环境下有不同的含义。在计算机编程语言中，*标识符*是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。*标识符*通常由字母和数字以及其它字符构成。\n*以上摘自百度百科*\n*****\n对于MC中的实体、方块、物品来说，相当于是命名空间:ID。","title":"标识符"},{"path":"命名空间.md","content":"# 命名空间\n即namespace，也称名称空间 。命名空间指定了某个东西的所有权，可以看作是文件夹，比如：\n有两个都叫做”file.txt“的文件，显然，它们无法放到同一目录下，但是可以先在该目录分别新建一个”a“文件夹和一个”b“文件夹，再将这两个file.txt文件分别放入不同文件夹就可以做到共存。\n换到Minecarft里而言就是：\n假如两个附加包里都有个叫做“item”的物品，你是无法同时使用的，先加载哪个包才能先加载哪个物品\r\n此时，**命名空间**就有作用了，如果一个改为“a:item”,另一个改为\"b:item\"，这样就不会冲突\n*****\n在上面的举例里，也知道了命名空间在MC中大多都是冒号左边的部分，但这并非全部，主要是物品、方块、实体、配方、特征、结构、动画、动画控制器方面。原版中的命名空间均为”minecraft“。\n命名空间的要求，在MC中是建议英文+数字或全英文，大小写都可，除非是改原版文件，否则请不要命名为”minecraft“\n取命名空间的名字这里提几个小建议：\n对于个人而言，可以是自己的名字的英文或拼音或缩写等\n对于集体而言，可以是集体的名称的英文或拼音或缩写等\n总之，取一些有代表性的，即起到了命名空间的作用，也起到了版权声明的作用。\n","title":"命名空间"},{"path":"优先权.md","content":"# 优先权\n即**priority**，一般称为*权重*。权重一般用于**实体行为**当中，并非是某个组件，而是一个键的名字，作用与它的名字一样——优先权。\n\n## 作用\n![](https://img.imgdb.cn/item/6013ca5f3ffa7d37b3564b93.png)\n在**实体行为**文件里基本上都能看到它的身影.\n实体组件类型中的行为组件决定着生物的各种行为，如跳、跑、攻击、发射、走等\n拿原版中的骷髅来说，完成一个靠近目标并射箭然后被反击逃跑的过程需要先 *环视→走→发射→ 跑*\n*****\n这些行为必须要有**一定顺序**的执行，否则就乱套了，因此*权重*的作用就体现出来了。\n**权重**会规定该行为的执行次序，priority的值为**非负整数**，最小为0，0代表最先，1其后。","title":"优先权"},{"path":"Nbt.md","content":"# NBT\n**二进制命名标签（Name Binary Tag）**，**NBT**格式为Minecraft中用于向文件中存储数据的一种存储格式。NBT格式以树形结构并配以许多标签的形式存储数据。所有的标签都有一个独立的ID和名称。最初的版本如Minecraft Beta1.3中所示为19132个标签，但是随着[铁砧](https://baike.baidu.com/item/%E9%93%81%E7%A0%A7/9549208)的引入，增加了一个整形指针变量，标签数量增加至19133个。在NBT格式最初在Minecraft Indev的版本中只有0到10这11个标签可用。\n## NBT的作用\n\nNBT在物品中就有，是数据标签的一种，通过修改物品的NBT可以自定义物品的伤害、耐久等。\n\n## NBT的定义\n每一个标签在数据树中都是一个独立的部分。标签的第一个字节为标签类型（ID）,其后两字节为存储名称的长度,之后以UTF-8格式的字符串的方式存储标签。尽管在默认的情况下Minecraft本身并不会存储带有空格的名称，但是标签名称可以包含空格。最后，取决于标签的类型，之后的字节为该标签的辅助信息。下表所示为在19133标签版本中二进制命名标签格式中所有12个已知的标签类型：\n| ID | 图标 | 标签类型 | 辅助信息 | 描述 |\n| --- | --- | --- | --- | --- |\n| **0** |  | TAG\\_**End** | 无 | 用于标记复合标签的结尾。本标签**无任何名称**所以只有一个零字节。 |\n| **1** |   \n　　 | TAG\\_**Byte** | 1字节 / 8位，有正负 | 有正负的整值数据类型，通常用于布尔表达式。 |\n| **2** |   \n　　 | TAG\\_**Short** | 2字节 / 16位，有正负，字节序：BE | 有正负的整值数据类型。 |\n| **3** |   \n　　 | TAG\\_**Int** | 4 字节 / 32 位，有正负，字节序：BE | 有正负的整值数据类型。 |\n| **4** |   \n　　 | TAG\\_**Long** | 8 字节 / 64 位，有正负，字节序：BE | 有正负的整值数据类型。 |\n| **5** |   \n　　 | TAG\\_**Float** | 4 字节 / 32 位，有正负，字节序：BE，IEEE 754-2008标准，binary32。 | 有正负的浮点数据类型。 |\n| **6** |   \n　　 | TAG\\_**Double** | 8 字节 / 64 位，有正负，字节序：BE，IEEE 754-2008标准，binary64。 | 有正负的浮点数据类型。 |\n| **7** |   \n　　 | TAG\\_**Byte**\\_**Array** | TAG\\_Int的辅助信息*大小*以及 TAG\\_Byte的辅助信息*大小*。 | 数组。 |\n| **8** |   \n　　 | TAG\\_**String** | 前2个字节(TAG\\_Short)存储字符串字符的个数(字符串的长度length).然后存储UTF-8标准的字符串,没有'\\\\0'结束符,只是以单纯的字符序列的形式存储. | 一个采用UTF-8标准的字符串，有尺寸限制，也就是说会以空结尾。 |\n| **9** |   \n　　 | TAG\\_**List** | 辅助信息的第1个字节(TAG\\_Byte)存储列表标签类型的ID,接下来的4个字节(TAG\\_Int)存储列表的size,接下来的字节将存储size个列表标签类型的辅助信息.假如第一个字节是0x08,id是8,对应的标签是TAG\\_String,如果size是0x00000004,接下来将会存储4个TAG\\_String标签的辅助信息.列表标签(既然都说了是列表)存储的内容都是相同类型的标签,所以只在第一个字节表明标签类型. | 一系列没有重复标签ID和标签名称的辅助信息。 |\n| **10** |   \n　　 | TAG\\_**Compound** | 标签的完整形式，需要附加TAG\\_End | 一系列完整的标签信息，包括ID、名称以及辅助信息等。任意两个标签都不会有相同的名称。 |\n| **11** |   \n　　 | TAG\\_**Int**\\_**Array** | 辅助信息前4个字节(TAG\\_Int)用于存储数组的大小size,紧接size\\*4 字节(TAG\\_Int)的数组数据.占用存储空间: 4+4\\**size Byte*。 | 存储TAG\\_Int的辅助信息的数组。 |","title":"Nbt"},{"path":"运行标识符.md","content":"# 运行标识符\n即**runtime_identifier**是实体行为文件`description`内的可选参数，用于模仿原实体的硬编码内容，允许使用 Minecraft原版的标识符。\n```json\n\"description\": {\n    \"identifier\": \"byh:entityA\",\n    \"is_spawnable\": false,\n    \"is_summonable\": true,\n    \"is_experimental\": false,\n    \"runtime_identifier\": \"minecraft:ender_crystal\"\n}\n```\n*****\n## 目前已知的标识符效果：\n### minecraft:shulker\n**潜影贝**\n*   1x1x1的实心碰撞盒。\n*   实体将停留在其产生的方块的中心。\n*   如果移除了其所附的障碍物，该实体将传送到附近的另一个畅通的位置。\n*   如果实体在非完整的块（例如床，平板等）上生成，它将传送到附近的另一个畅通的位置。\n*   固体碰撞盒的宽度和高度不能更改。\n\n### minecraft:ender_crystal\n**末影水晶**\n*   实体将停留在其产生的方块的中心。\n*   除非传送，否则实体将始终保持其位置。\n*   可以放在任何表面上\n*   始终会被其他实体推动。\n*   无法配置为受到伤害。\n*   无法更改其面对的方向。\n\n### minecraft:parrot\n**鹦鹉**\n*   使翅膀动画能够正常运行。\n*   使暴民缓慢下落。\n*   使实体在唱片机播放音乐时会随之舞动。\n\n### minecraft:armor_stand\n**盔甲架**\n*   取消实体阴影\n*   攻击实体会使实体立刻消失\n*   可放在其它实体上，且可从实体身上穿戴移除装备\n\n### minecraft:iron_golem\n**铁傀儡**\n*   攻击可通过垂直放大增加击退\n*   加快手臂和腿部动画的速度（可以手动固定，速度约为1/4）\n*   与村民的逻辑互动可能较差。\n\n### minecraft:arrow\n**箭**\n*   禁用死亡动画，声音和粒子\n*   使实体的阴影变小，但不会使其消失\n*   无法与之互动\n*   如果是通过生物蛋或/summon指令生成的，则当玩家与实体接触时向其显示一个箭头，然后将其自身移除\n\n### minecraft:thrown_trident\n**三叉戟**\n*   禁用死亡动画，声音和粒子\n*   使实体的阴影变小，但不会使其消失\n*   无法与之互动\n\n### minecraft:piglin\n**猪灵**\n*   允许`minecraft:celebrate_hunt`运行（允许使用query.is\\_celebrating）\n\n### minecraft:spider\n**蜘蛛**\n*   允许蜘蛛网不减慢实体速度\n\n### minecraft:minecart\n**矿车**\n*   禁用实体阴影\n*   使实体在死亡时掉落矿车\n*   防止实体旋转\n\n## minecraft:boat\n**船**\n*   骑行时添加口袋船UI\n*   防止实体旋转\n\n## minecraft:sheep\n**羊**\n*   允许`query.is_grazing`与`behavior.eat_block`组件一起使用\n\n## minecraft:panda\n**熊猫**\n*   允许`query.is_grazing`和`query.sit_mount`与`minecraft:behavior.random_sitting`组件一起使用\n\n## minecraft:wither_skull_dangerous\n**凋零之首**\n*   使实体掉落死亡凋零\n*   被该实体杀死的任何实体都会在死亡的地方放置凋零玫瑰。奇怪的是，僵尸似乎掉下了凋零的玫瑰，而不是将其放置在死亡的地点。\n*   使实体不断生成粒子（生成的粒子的标识符为`minecraft:basic_smoke_particle`）\n*   使实体不受重力影响（这似乎导致实体`minecraft:projectile`沿直线移动）\n*   防止实体受到损害\n*   仅适用于没有AI目标的实体（因此仅适用于虚拟实体和弹丸）","title":"运行标识符"},{"path":"专辑篇.md","content":"# 专辑篇\n本篇会对之前入门教程草草了事的部分以及其它较难的地方进行详细深入讲解，如交易列表、战利品表（掉落物表）、实体生成、滤器、触发器与事件等。\n","title":"专辑篇"},{"path":"交易列表.md","content":"","title":"交易列表"},{"path":"战利品表.md","content":"","title":"战利品表"},{"path":"实体生成.md","content":"","title":"实体生成"},{"path":"滤器.md","content":"","title":"滤器"},{"path":"触发器与事件.md","content":"","title":"触发器与事件"},{"path":"Molang.md","content":"# MoLang\n亦叫**MoLang表达式**。MoLang是一种简单的基于表达式的语言，为实时且快速地计算数值而设计。它的设计重点是在JavaScript无法大规模执行的需要更高性能的系统中启用类似脚本的功能。\nMolang主要是被用在实体的动画控制器里，有时也会用在实体行为、实体entity定义、渲染控制器、特征等地方。\n\n## 语法\nMolang的入门门槛极低，只要有些编程经验一会儿就能学会，即使不怎么会编程，但是只要初中数学好也可以。\nMoLang语言结构主要基于简单的C样式语法，专于处理数学表达式。对于简要情况，脚本由一个表达式组成；而在需要中间值，或有助于减少计算时间的情况下，则可由多个表达式组成。\n所有情况下，脚本中最后一个表达式的值会提供该脚本的值。在多表达式脚本中，除最后一个表达式外，所有表达式都必须为变量分配一个值。最后一个表达式也可分配，然而并不需要，因为它的值被默认用作返回值。\n*以上改编自[MinecraftWiki]()*\n\n### 变量\n一个变量可能属于以下几个域  \n\n| 域 | 范围 | 示例 |\n| --- | --- | --- |\n| temp | 当前表达式 | temp.foo = math.sin(query.anim\\_time); return temp.foo \\* temp.foo; |\n| variable | 只读值，通常指向当前实体 | variable.my\\_saved\\_var = variable.my\\_saved\\_var + 1; |\n| query | 只读值，通常指向当前实体 | query.is\\_baby |\n| geometry | 当前渲染控制器（控制使用的几何模型） | \"geometry\": \"array.geos\\[query.is\\_sheared\\]\" |\n| material | 当前渲染控制器（与生物体自身发光等效果相关，选项固定，对应文件不开源） | \"materials\": \\[ { \"\\*\": \"material.default\" }, { \"leg\\*\": \"material.legs\" } \\] |\n| texture | 当前渲染控制器（控制生物使用的材质贴图） | \"textures\": \\[\"array.skins\\[query.is\\_saddled\\]\"\\] |\n\n### 值\n所有数值均为浮点数。  \n分别将布尔值转换并存储为0.0或1.0的浮点值（分别为false或true）。  \n对于布尔测试，等于0.0的浮点值为false，不等于0.0的任何值为true。  \n对于数组索引，浮点数以C样式转换为整数，对于负值，浮点数限制为零；对于大值，浮点数由数组大小包装。  \n其他受支持的类型为：  \n~~~\nGeometry模型\nTexture纹理\nMaterial材料\nActor Reference参与者参考\nActor Reference Array参与者引用数组\nString字符串\nStruct数据结构\n~~~\n如果错误则返回0.0\n\n### 关键字\n| 关键字 | 描述 |\n| --- | --- |\n| floa | 数值常量值 |\n| ( ) | 圆括号用于控制运算表达式的先后顺序 |\n| [ ] | 方括号用于数组存取 |\n| {{`}} | 大括号执行范围 |\n| query | 访问实体的属性 |\n| math | 各种数学方法(见下表) |\n| temp | 在当前表达式中存储一个临时变量 |\n| variable | 在当前实体身上存储一个变量供使用 |\n| geometry | 在实体定义中指向一个贴图 |\n| material | 在实体定义中指向一个贴图 |\n| texture | 在实体定义中指向一个贴图 |\n| this | 在运行这个表达式前的值（上下文相关） |\n| return | 在复杂的表达式中，这个关键字会在返回后面的表达式的值后停止运算 |\n| ?? | 空合并运算符，用于处理缺少的变量或过时的actor引用 |\n| -> | 箭头运算符，用于访问来自不同实体的数据 |\n| context | 在某些情况下游戏提供的只读存储 |\n| loop | 用于重复一个或多个命令“ n”次  |\n| for\\_each | 用于遍历实体数组 |\n| break | 用于及早退出循环/ for\\_each范围 |\n| continue | 用于跳过循环/ for\\_each迭代的其余语句集并移至下一个迭代  |\n| + | 基础数学运算符，加 |\n| - | 基础数学运算符，减 |\n| * | 基础数学运算符，乘 |\n| / | 基础数学运算符，除 |\n| ==  | 比较运算符，等于 |\n| != | 比较运算符，不等于 |\n| > | 比较运算符，大于 |\n| < | 比较运算符，小于 |\n| >= | 比较运算符，大于等于 |\n| <= | 比较运算符，小于等于 |\n| === | 比较运算符，绝对等于 |\n| !== | 比较运算符，绝对不等于 |\n| ! | 逻辑运算符，否 |\n| && | 逻辑运算符，和 |\n| \\|\\|  | 逻辑运算符，或 |\n| 条件表达式 ? 如果真 | 条件运算符（二元表达式） |\n| 条件表达式 ? 如果真 : 如果假 | 条件运算符（三元表达式） |\n\n**三元表达式**\n诸如C、Java、JS、Py这些编程语言中都有三元表达式，基本用法也相同。\n* 问号“?”前面的为条件表达式，何为条件表达式？\n\"1 \\* 1 + 1 == 3\"这就是一个条件表达式，将会检测最终返回的值是否符合比较运算符，是就再次返回true真，不是则返回false假。\n1乘1加1是明显不等于3的，所以返回假false。如果是\"1 \\* 1 + 1 != 3”那将返回true，因为1乘1加1确实不等于3，符合比较运算符。\n* 问号\"?\"后面是两个新的表达式。这两个表达式被冒号“:”隔开\n冒号前面的表达式将会在条件表达式返回true时执行，后面的表达式则是在条件表达式返回false时执行。\n\n### 缩写\n为了减少打字负担并在阅读和编写molang时一目了然，因此以下关键字都有缩写形式。\n| 全名 | 缩写 |\n| --- | --- |\n| context.moo | c.moo |\n| query.moo | q.moo |\n| temp.moo | t.moo |\n| variable.moo | v.moo |\n就比如：  \n~~~js\nmath.sin(query.life_amount * math.sqrt(variable.ac / (233 - query.moving + variable.i ) ) ) + variable.i * query.is_jumping\n~~~\n可以这样缩写\n~~~js\nm.sin(q.life_amount * m.sqrt(v.ac / (233 - q.moving + v.i ) ) ) + v.i * q.is_jumping\n~~~\n也可以两种形式一起食用\n~~~js\nmath.sin(q.life_amount * m.sqrt(variable.ac / (233 - query.moving + v.i ) ) ) + v.i * query.is_jumping\n~~~ \n### 结构\n数据结构与C不同，是通过用法隐式定义的。它们的目的是更有效地传递数据，例如传递v.location而不是vx，vy和vz。例如：\n~~~js\nv.location.x = 1 ; \nv.location.y = 2 ; \nv.location.z = 3 ; \nv.another_mob_set_elsewhere -> v.first_mobs_location = v.location;\n~~~\n\n### 弦\nmolang中的字符串用单引号引起来，例如：'minecraft：pig'或'hello world！'。空字符串定义为两个背对背的单引号。字符串操作仅支持`= =`和`！\\=`此时。  \n注意：字符串不支持'字符，因为目前不支持转义字符。\n\n### \\->箭头运算符\n查询函数的某些返回值或存储在temp / entity / context变量中的值可以是对另一个实体的引用。“->”运算符允许脚本访问该实体上的变量或运行查询。例如，下面的示例将查找当前实体四米以内的所有猪（如果是猪，则包括其自身），如果每只猪上方的块易燃（例如，橡树按钮），则在其自身上增加变量vx ）：  \n请注意，如果`->`运算符的左手边有错误（值是null，该实体先前被杀死，或其他问题），则表达式将不会计算右手边并将返回0。此实现样式是在性能之间进行选择的，而不是要求内容创建者过分担心在任何地方检查潜在不良值的选择。  \n~~~js\n\"v.x = 0;\nfor_each(v.pig, query.get_nearby_entities(4, 'minecraft:pig'), {\n    v.x = v.x + v.pig->query.get_relative_block_state(0, 1, 0, 'flammable');\n});\"\n~~~\n\n### 公共变量\n通常，一个暴徒的变量被认为是该暴徒的私有变量，而另一个变量无法访问。若要将变量对其他生物的只读访问权限，您需要在所属实体的资源定义中对该变量设置“公共”设置。还建议默认初始化变量。  \n~~~json\n{\n  \"format_version\": \"1.10.0\",\n  \"minecraft:client_entity\": {\n    \"description\": {\n      ...\n      \"scripts\": {\n        \"variables\": {\n          \"variable.oink\": \"public\"\n        },\n        \"initialize\": [\n          \"variable.oink = 0;\"\n        ],\n        ...\n      },\n      ...\n    }\n  }\n}\n~~~  \n  \n### {}括号范围定界符\n通过将它们用{和}符号包装，可以将一系列语句分组为一组。这主要用于循环和条件语句中：  \n~~~js\n(v.moo > 0) ? {\n  v.x = math.sin(q.life_time * 45);\n  v.x = v.x * v.x + 17.3;\n  t.sin_x = math.sin(v.x);\n  v.x = t.sin_x * t.sin_x + v.x * v.x;\n  v.x = math.sqrt(v.x) * v.x * math.pi;\n}\n~~~.\n\n### loop\n\n有时您想多次执行一个表达式。您可以使用`loop（count，expression）;`而不是将其粘贴粘贴。为了安全起见，我们现在对它们施加了一些任意限制。最大循环计数器是（在撰写本文时）1024。此外，请注意，尽管您可以将循环嵌套在所需的深度内，但是要小心不要循环太久，它会挂断您的游戏。  \n斐波那契计算器  \n~~~js\nv.x = 1;\nv.y = 1;\nloop(10, {\n  t.x = v.x + v.y;\n  v.x = v.y;\n  v.y = t.x;\n});\n~~~\n\n### for\\_each\n\nquery.get\\_nearby\\_entities（请参阅下文）返回实体数组。为了遍历它们，可以使用以下新的内置函数“ for\\_each”。它带有三个参数：for\\_each（variable，array，expression）;变量可以是任何变量，可以是temp或variable，尽管我建议使用temp来不污染实体的变量。可变空间。该表达式是您要为数组中的每个条目执行的任何molang表达式）  \n  \n\n### break\n这将退出loop循环或 for\\_each。  \n~~~js\nv.x = 1;\nv.y = 1;\nloop(10, {t.x = v.x + v.y; v.x = v.y; v.y = t.x; (v.y > 20) ? break;});\n~~~\n  \n按照C语言样式规则，这将立即退出最内部的活动循环。如果你有：  \n~~~js\nv.x = 0;\nloop(10, {loop(10, {v.x = v.x + 1; (v.x > 5) ? break;});});\n~~~\n当`vx> 5`时，`break`语句将终止内部循环，并继续处理外部循环的脚本。注意，由于没有在外部循环之间重置vx，因此第二次进入内部循环将在`vx`处再添加一个，然后再次退出内部循环，导致`vx`的最终值为6 + 1 + 1 + 1 + ... + 1` =`15`）  \n\n### continue\n`continue`按照C风格语言规则运行。当前仅在循环中受支持，它将跳至当前循环的下一个迭代。有关内部/外部循环的更多详细信息，请参见上面的`break`。以下示例将导致vx变为6.0，因为一旦达到该值，增量将被跳过。请注意，在这个人为的示例中，最好跳出循环，因为与继续执行所有10次迭代相比，它的性能更高。  \n ~~~js\nv.x = 0;\nloop(10, {\n  (v.x > 5) ? continue;\n  v.x = v.x + 1;\n});\n~~~\n\n### ??空合并运算符  \n类似于空值运算符在C＃中的工作方式，现在可以引用一个可能存在或不存在的变量，而不会看到内容错误。如果没有，您现在可以提供要使用的默认值。以前，如果变量不存在，则会出现内容错误。这是为了确保始终正确正确地初始化变量，以避免未初始化的变量错误。不幸的是，这随后需要初始化脚本，或者在某些情况下，需要一些复杂的解决方法来确保变量已初始化。现在，如果您知道在脚本的第一次运行中不会初始化变量，则可以使用以下命令：  \n~~~json\nvariable.x = (variable.x ?? 1.2) + 0.3;\n~~~\n这将使用variable.x`的'价值，如果它是有效的，否则，如果1.2`variable.x`：  \n\\-尚未初始化  \n\\-是已删除的实体的引用  \n\\-是一个无效的引用  \n\\-拥有一个错误  \n  \n提示“ ??”运算符将与“ variable。” s，“ temp。” s和“ context。” s一起使用，这些变量包含数字或实体引用，但不包含诸如材料，纹理或几何体之类的资源（因为这些必须存在并且有效，否则是内容错误）。如果第一个参数导致无法解决的问题，它将返回第二个参数。 \n\n### 简单与复杂表达式\n简单表达式是单个语句\n~~~js\nmath.sin(query.anim_time * 1.23)\n~~~ \n  \n复杂表达式是具有多个语句的表达式，每个语句均以“;”结尾。每个语句按顺序进行评估。在当前的实现中，最后一条语句要求使用return关键字并定义表达式的结果值。例如：  \n~~~js\ntemp.moo = math.sin(query.anim_time * 1.23);\ntemp.baa = math.cos(query.life_time + 2.0);\nreturn temp.moo * temp.moo + temp.baa;\n~~~  \n  \n注意，在简单的表达式中，不允许使用“;”，而在复杂的表达式中，每个语句都需要使用“;”（包括最后一个）。另外，请注意，如果您不从复杂表达式中“返回”值，则该表达式的计算结果将为0.0。  \n\n## 数学函数\n| 函数 | 描述 |\n| --- | --- |\n| \"math.abs(value)\" | value的绝对值 |\n| \"math.sin(value)\" | value的正弦值 |\n| \"math.cos(value)\" | value的余弦值 |\n| \"math.exp(value)\" | value以e为底数的指数函数 |\n| \"math.ln(value)\" | value以e为底数的对数函数 |\n| \"math.pow(base, exponent)\" | 返回base的exponent次幂 |\n| \"math.sqrt(value)\" | value的平方根 |\n| \"math.random(low, high)\" | 在最小值到最大值之间的随机数 |\n| \"math.ceil(value)\" | 数字的向上取整 |\n| \"math.round(value)\" | 数字四舍五入取整 |\n| \"math.trunc(value)\" | 截短法取整，这种方式在处理负数时是向上取整 |\n| \"math.floor(value)\" | 向下取整 |\n| \"math.mod(value, denominator)\" | value 除以 denominator后的余数 |\n| \"math.min(A, B)\" | 返回A和B中的最小值 |\n| \"math.max(A, B)\" | 返回A和B中的最大值 |\n| \"math.clamp(value, min, max)\" | 把value限定在最小值和最大值之间 |\n| \"math.lerp(start, end, 0\\_to\\_1)\" | 在start和end之间根据0~1取中间值，即start+(end-start)\\*0\\_to\\_1 |\n| \"math.lerprotate(start, end, 0\\_to\\_1)\" | 作为角度，在start和end之间根据0~1取中间值，360度时会有跨越 |\n| \"math.atan（value）\" | 值的奥秘 |\n| \"math.atan2（y，x）\" | y / x的反正切。注意参数的顺序 |\n| \"math.die\\_roll（num，low，high）\" | 返回“ num”个随机数的总和，每个值的范围从低到高。注意：生成的随机数不是像普通骰子那样的整数。为此，请使用math.die\\_roll\\_integer。 |\n| \"math.die\\_roll\\_integer（num，low，high）\" | 返回“ num”个随机整数的总和，每个整数的值从低到高。注意：生成的随机数是类似于正常骰子的整数。 |\n| \"math.hermite_blend（value）\" | 使用Hermite基础函数之一进行简单的平滑曲线插值很有用：`3t ^ 2-2t ^ 3`。请注意，尽管任何有效的float都是有效的输入，但此功能在\\[0,1\\]范围内效果最佳。 ||\n| \"math.pi | 返回常量pi的float表示形式。 |\n| \"math.pow（base，exponent）\" | 将“基础”提升至“指数”次幂 |\n| \"math.random（low，high）\" | 上下限之间的随机值 |\n| \"math.random\\_integer（low，high）\" | 上下限之间的随机整数值 |\n\n## 查询功能\n查询函数是布尔表达式，允许您在不同情况下查询拥有的值。可以在MoLang表达式中使用。如果村民是幼儿，可用于控制更改位置，纹理，动画等内容。\n~~~js\n\"position\": [ 0.0, \"query.is_baby ? -8.0 : 0.0\", \"query.is_baby ? 4.0 : 0.0\" ]\n~~~\n\n### 实体查询列表\n| 名称 | 描述 |\n| --- | --- |\n| query.all\\_animations\\_finished | 仅在动画控制器中有效。如果当前动画控制器状态下的所有动画至少播放了一次，则返回1.0，否则返回0.0。 |\n| query.anim\\_time | 返回自当前动画开始以来的时间（以秒为单位），否则返回0.0（如果未在动画中调用） |\n| query.any\\_animation\\_finished | 仅在动画控制器中有效。如果当前动画控制器状态下的任何动画至少播放了一次，则返回1.0，否则返回0.0。 |\n| query.armor\\_color\\_slot | 将装甲插槽索引作为参数，并返回请求的插槽中装甲的颜色 |\n| query.armor\\_material\\_slot | 将装甲插槽索引作为参数，并在请求的装甲插槽中返回装甲材料类型 |\n| query.armor\\_texture\\_slot | 将装甲插槽索引作为参数，并返回所请求插槽的纹理类型 |\n| query.blocking | 如果实体正在阻止，则返回1.0，否则返回0.0 |\n| query.body\\_y\\_rotation | 如果在actor上调用，则返回身体偏航旋转，否则返回0.0 |\n| query.can\\_climb | 如果实体可以爬升，则返回1.0，否则返回0.0 |\n| query.can\\_fly | 如果实体可以飞行，则返回1.0，否则返回0.0 |\n| query.can\\_power\\_jump | 如果实体可以跳跃，则返回1.0，否则返回0.0 |\n| query.can\\_swim | 如果实体可以游泳则返回1.0，否则返回0.0 |\n| query.can\\_walk | 如果实体可以行走，则返回1.0，否则返回0.0 |\n| query.current\\_squish\\_value | 返回当前实体的压缩值，如果没有意义，则返回0.0 |\n| query.delta\\_time | 返回自上一帧以来的时间（以秒为单位） |\n| query.frame\\_alpha | 返回正在渲染此帧的AI刻度之间的比率（从0到1） |\n| query.ground\\_speed | 以米/秒为单位返回实体的地面速度 |\n| query.has\\_armor\\_slot | 将装甲插槽索引作为参数，如果实体在请求的插槽中有装甲，则返回1.0，否则返回0.0 |\n| query.has\\_collision | 如果实体启用了碰撞，则返回1.0，否则返回0.0 |\n| query.has\\_gravity | 如果实体受重力影响，则返回1.0，否则返回0.0 |\n| query.has\\_owner | 如果实体具有所有者ID，则返回true，否则返回false |\n| query.has\\_rider | 如果实体有骑手，则返回1.0，否则返回0.0 |\n| query.has\\_target | 如果实体具有目标，则返回1.0，否则返回0.0 |\n| query.head\\_roll\\_angle | 返回狼实体头部的侧倾角 |\n| query.head\\_x\\_rotation | 将一个参数作为参数。如果有意义，则返回该实体的第n个头部x旋转，否则返回0.0 |\n| query.head\\_y\\_rotation | 将一个参数作为参数。如果有意义，则返回实体的第n个头y旋转，否则返回0.0 |\n| query.invulnerable\\_ticks | 如果有意义的话，返回实体剩余的无痕数，否则返回0.0 |\n| query.is\\_angry | 如果实体生气则返回1.0，否则返回0.0 |\n| query.is\\_avoiding\\_mobs | 如果实体逃离暴民则返回1.0，否则返回0.0 |\n| query.is\\_baby | 如果实体是婴儿，则返回1.0，否则返回0.0 |\n| query.is\\_breathing | 如果实体呼吸，则返回1.0，否则返回0.0 |\n| query.is\\_bribed | 如果实体已经贿赂，则返回1.0，否则返回0.0 |\n| query.is\\_carrying\\_block | 如果实体携带一个块，则返回1.0，否则返回0.0 |\n| query.is\\_casting | 如果实体正在投射，则返回1.0，否则返回0.0 |\n| query.is\\_charged | 如果实体已收费，则返回1.0，否则返回0.0 |\n| query.is\\_charging | 如果实体正在收费，则返回1.0，否则返回0.0 |\n| query.is\\_chested | 如果实体已连接箱子，则返回1.0，否则返回0.0 |\n| query.is\\_critical | 如果实体是关键的，则返回1.0，否则返回0.0 |\n| query.is\\_dancing | 如果实体在跳舞，则返回1.0，否则返回0.0 |\n| query.is\\_delayed\\_attacking | 如果实体使用延迟攻击进行攻击，则返回1.0，否则返回0.0 |\n| query.is\\_eating | 如果实体正在吃饭，则返回1.0，否则返回0.0 |\n| query.is\\_elder | 如果实体是旧版本，则返回1.0，否则返回0.0 |\n| query.is\\_enchanted | 如果附魔该实体，则返回1.0，否则返回0.0 |\n| query.is\\_fire\\_immune | 如果该实体不受射击，则返回1.0，否则返回0.0 |\n| query.is\\_first\\_person | 如果实体以第一人称模式渲染，则返回1.0，否则返回0.0 |\n| query.is\\_gliding | 如果实体滑动，则返回1.0，否则返回0.0 |\n| query.is\\_grazing | 如果实体在放牧，则返回1.0；否则，则返回0.0 |\n| query.is\\_idling | 如果实体闲置，则返回1.0，否则返回0.0 |\n| query.is\\_ignited | 如果实体被点燃，则返回1.0，否则返回0.0 |\n| query.is\\_illager\\_captain | 如果实体是前卫队长，则返回1.0，否则返回0.0 |\n| query.is\\_in\\_love | 如果实体恋爱，则返回1.0，否则返回0.0 |\n| query.is\\_in\\_water | 如果实体在水中，则返回1.0，否则返回0.0 |\n| query.is\\_in\\_water\\_or\\_rain | 如果实体在水或雨中，则返回1.0，否则返回0.0 |\n| query.is\\_interested | 如果该实体感兴趣，则返回1.0，否则返回0.0 |\n| query.is\\_invisible | 如果实体不可见，则返回1.0，否则返回0.0 |\n| query.is\\_jumping | 如果实体在跳跃，则返回1.0，否则返回0.0 |\n| query.is\\_laying\\_down | 如果实体放下则返回1.0，否则返回0.0 |\n| query.is\\_laying\\_egg | 如果实体下蛋，则返回1.0，否则返回0.0 |\n| query.is\\_leashed | 如果实体被释放，则返回1.0，否则返回0.0 |\n| query.is\\_lingering | 如果实体徘徊，则返回1.0，否则返回0.0 |\n| query.is\\_moving | 如果实体正在移动，则返回1.0，否则返回0.0 |\n| query.is\\_on\\_ground | 如果实体在地面上，则返回1.0，否则返回0.0 |\n| query.is\\_onfire | 如果实体着火则返回1.0，否则返回0.0 |\n| query.is\\_orphaned | 如果该实体是孤立的，则返回1.0，否则返回0.0 |\n| query.is\\_powered | 如果实体已通电，则返回1.0，否则返回0.0 |\n| query.is\\_pregnant | 如果实体已怀孕，则返回1.0，否则返回0.0 |\n| query.is\\_resting | 如果实体处于静止状态，则返回1.0，否则返回0.0 |\n| query.is\\_riding | 如果实体在骑行，则返回1.0，否则返回0.0 |\n| query.is\\_roaring | 如果实体当前正在咆哮，则返回1.0，否则返回0.0 |\n| query.is\\_rolling | 如果实体正在滚动，则返回1.0，否则返回0.0 |\n| query.is\\_saddled | 如果实体有鞍，则返回1.0，否则返回0.0 |\n| query.is\\_scared | 如果该实体感到害怕，则返回1.0，否则返回0.0 |\n| query.is\\_shaking | 如果实体正在投射，则返回1.0，否则返回0.0 |\n| query.is\\_shaking\\_wetness | 如果实体正在甩水，则返回true |\n| query.is\\_sheared | 如果实体能够被剪切并被剪切，则返回1.0，否则返回0.0 |\n| query.is\\_shield\\_powered | 如果该实体有意义，则返回1.0f（如果该实体具有活动的有源屏蔽），否则返回0.0 |\n| query.is\\_silent | 如果实体为静默则返回1.0，否则返回0.0 |\n| query.is\\_sitting | 如果实体坐着，则返回1.0，否则返回0.0 |\n| query.is\\_sleeping | 如果实体正在睡眠，则返回1.0，否则返回0.0 |\n| query.is\\_sneaking | 如果实体正在潜行，则返回1.0，否则返回0.0 |\n| query.is\\_sneezing | 如果实体在打喷嚏，则返回1.0，否则返回0.0 |\n| query.is\\_sprinting | 如果实体正在冲刺，则返回1.0，否则返回0.0 |\n| query.is\\_stackable | 如果实体是可堆叠的，则返回1.0，否则返回0.0 |\n| query.is\\_standing | 如果实体站立，则返回1.0，否则返回0.0 |\n| query.is\\_stunned | 如果该实体当前处于眩晕状态，则返回1.0，否则返回0.0 |\n| query.is\\_swimming | 如果实体正在游泳，则返回1.0，否则返回0.0 |\n| query.is\\_tamed | 如果已驯服实体，则返回1.0，否则返回0.0 |\n| query.is\\_transforming | 如果实体正在变换，则返回1.0，否则返回0.0 |\n| query.is\\_using\\_item | 如果实体正在使用项目，则返回1.0，否则返回0.0 |\n| query.is\\_wall\\_climbing | 如果实体正在爬墙，则返回1.0，否则返回0.0 |\n| query.item\\_in\\_use\\_duration | 以秒为单位返回商品的使用时间（最长持续时间），否则返回0.0。 |\n| query.item\\_max\\_use\\_duration | 返回该项目可以使用的最长时间，否则返回0.0。 |\n| query.item\\_remaining\\_use\\_duration | 返回项目剩余可使用的时间（以秒为单位），否则返回0.0。 |\n| query.key\\_frame\\_lerp\\_time | 返回上一个和下一个关键帧之间的比率 |\n| query.lie\\_amount | 返回实体的躺下数量 |\n| query.life\\_span | 返回实体的有限寿命，如果实体永久存在，则返回0.0 |\n| query.life\\_time | 返回自当前动画开始以来的时间（以秒为单位），否则返回0.0（如果未在动画中调用） |\n| query.log | 调试日志值 |\n| query.mark\\_variant | 返回实体的mark变体 |\n| query.max\\_trade\\_tier | 如果有意义，则返回实体的最大交易层，否则返回0.0 |\n| query.model\\_scale | 返回当前实体的比例 |\n| query.modified\\_distance\\_moved | 返回实体在水平方向上移动的总距离（以米为单位）（自从上次加载以来，不一定是最初创建实体以来），该状态由状态标记（例如is\\_baby或on\\_fire）修改 |\n| query.modified\\_move\\_speed | 返回由状态标志（例如is\\_baby或on\\_fire）修改的实体的当前行走速度 |\n| query.overlay\\_alpha | 请勿使用-此功能已弃用，将被删除 |\n| query.previous\\_squish\\_value | 返回当前实体的前一个压缩值，如果没有意义，则返回0.0 |\n| query.roll\\_counter | 返回实体的滚动计数器 |\n| query.shake\\_angle | 返回狼实体的摇动角度 |\n| query.sit\\_amount | 返回实体的当前坐席量 |\n| query.skin\\_id | 返回实体的皮肤ID |\n| query.sneeze\\_counter | 返回实体的打喷嚏计数器 |\n| query.spellcolor.b | 如果有意义，则返回当前实体拼写颜色的蓝色通道，否则返回0.0 |\n| query.spellcolor.g | 如果可行，则返回当前实体拼写颜色的绿色通道，否则返回0.0 |\n| query.spellcolor.r | 如果有意义，则返回当前实体拼写颜色的红色通道，否则返回0.0 |\n| query.standing\\_scale | 返回实体的站立程度 |\n| query.swell\\_amount | 返回实体的肿胀程度 |\n| query.swelling\\_dir | 如果有意义，则返回实体的膨胀方向，否则返回0.0 |\n| query.tai​​l\\_angle | 返回狼实体尾巴的角度，否则返回0.0 |\n| query.target\\_x\\_rotation | 如果有一个，则返回瞄准当前目标的x旋转，否则返回0.0 |\n| query.target\\_y\\_rotation | 如果有一个，则返回瞄准实体当前目标所需的y旋转，否则返回0.0 |\n| query.time\\_stamp | 返回级别的当前时间戳 |\n| query.trade\\_experience | 返回有意义的实体当前交易经验，否则返回0.0 |\n| query.trade\\_tier | 如果有意义，则返回实体的贸易层，否则返回0.0 |\n| query.unhappy\\_counter | 返回实体的不满意程度 |\n| query.variant | 返回实体的变种值 |\n| query.wing\\_flap\\_position | 返回实体的襟翼位置，如果没有意义，则返回0.0 |\n| query.wing\\_flap\\_speed | 返回实体的机翼襟翼速度；如果没有意义，则返回0.0 |\n| query.yaw\\_speed | 返回实体的偏航速度 |\n\n","title":"MoLang"},{"path":"动画与动画控制器.md","content":"","title":"动画与动画控制器"},{"path":"渲染控制器.md","content":"# 渲染控制器\n即**Render Controllers**，是实体在资源包中的重要部分之一，定义了实体的渲染，与`materials`也有密不可分的关系。\n渲染控制器的文件被存储在资源包根目录的render_controllers文件夹内\n****\n## 解释\n最基本的渲染控制器：\n~~~\n{\n  \"format_version\": \"1.8.0\",\n  \"render_controllers\": {\n    \"controller.render.byh_entity\": {\n      \"geometry\": \"Geometry.default\",\n      \"materials\": [ { \"*\": \"Material.default\" } ],\n      \"textures\": [ \"Texture.default\" ]\n    }\n  }\n}\n~~~\n“controller.render.byh_entity”即为该渲染控制器的标识符，注意，这与普通标识符的格式不一样\n渲染控制器标识符格式大都为：controller.render.xxxx，前面是不可变的\n接下来看标识符内的对象，分别是模型、材料、纹理（贴图）\n* 模型的定义：`\"geometry\": \"Geometry.default\"`，这意味着要在该实体上渲染的模型是简称为“ default”的模型。\n* 材料定义了游戏中的渲染方式。可以在不同部位上渲染不同的材质。星号“*“可替换成部位骨骼的名称。星号本身是指所有骨骼。举例：如果是换成`byh_`，那么所有名称以此开头的骨骼都将使用此材料进行渲染。\n* 纹理（贴图）定义：`\"textures\": \"Texture.default\"`：这意味着要在该实体上渲染的纹理是简称为“ default”的纹理。\n*****\n\n## 不同纹理(贴图)实体\n原版狐狸渲染控制器示例：\n```\n{\n  \"format_version\": \"1.8.0\",\n  \"render_controllers\": {\n    \"controller.render.fox\": {\n      \"arrays\": {\n        \"textures\": {\n          \"Array.skins\": [\n            \"Texture.red\",\n            \"Texture.arctic\"\n          ]\n        }\n      },\n      \"geometry\": \"Geometry.default\",\n      \"materials\": [ { \"*\": \"Material.default\" } ],\n      \"textures\": [ \"Array.skins[query.variant]\" ]\n    }\n  }\n}\n```\n狐狸资源包entity定义内：\n```\n  \"textures\": {\n    \"red\": \"textures/entity/skele_yaklin\",\n    \"arctic\": \"textures/entity/skele_yaklin_arctic\"\n  }\n```\n首先映入眼帘发现不同的地方是，在标识符内多了个一个名为“arrays”的对象，实际上这里键的名字是可自定义的。\n`arrays`定义了该实体的不同纹理贴图，分别有`red`和`arctic`\n其中“red”为默认纹理，\"arctic\"为北极狐的纹理\n*   “ Array.skins”同时包含“ Texture.red”和“ Texture.arctic”\n*   “纹理”通常具有`[ \"Texture.default\" ]`，但是这里却没有。因为，已经有`[ \"Array.skins[query.variant]\" ]`\n这是一段**Molang**，作用是查询实体的变种值，而变种值是在实体行为文件的组件组里就设置好了的\n```json\n    \"red\": {\n        \"minecraft:variant\": {\n            \"value\": 0\n        }\n    },\n    \"arctic\": {\n        \"minecraft:variant\": {\n            \"value\": 1\n        }\n    }\n```\n这样 结构或许就非常清晰了，带有不同变种值的组件组将会在该实体生成时被`minecraft:entity_spawned`事件触发到，然后会以设置好的几率来随机添加这些变种值的组件组中的任意一个。\n*****\n## 骨骼的可见性\n不说废话，直接上示例：\n依旧是狐狸的\n~~~\n{\n  \"format_version\": \"1.8.0\"A,\n  \"render_controllers\": {\n    \"controller.render.fox\": {\n      \"arrays\": {\n        \"textures\": {\n          \"Array.skins\": [\n            \"Texture.red\",\n            \"Texture.arctic\"\n          ]\n        }\n      },\n      \"geometry\": \"Geometry.default\",\n\n      \"part_visibility\": [\n        { \"leg*\": \"!query.is_sleeping\" },\n        { \"head\": \"!query.is_sleeping\" },\n        { \"head_sleeping\": \"query.is_sleeping\" }\n      ],\n\n      \"materials\": [ { \"*\": \"Material.default\" } ],\n      \"textures\": [ \"Array.skins[query.variant]\" ]\n    }\n  }\n}\n\n~~~\n\n使用渲染控制器时，可以在“ part_visibility”数组中设置指定骨骼在指定条件下隐藏。\n语法：\n```\n{\"要隐藏的骨骼名字\": \"条件（Molang表达式）\"}\n```\n示例：\n~~~\n{ \"leg*\": \"!query.is_sleeping\" }\n\n~~~\n`!query.is_sleeping`返回true，即狐狸没有睡觉的时候，所有以“leg”（腿）开头的骨骼都可见。如若返回false，即狐狸在睡觉，将会隐藏以“leg”开头的骨骼。","title":"渲染控制器"},{"path":"材料.md","content":"# 材料\n即**Materials**，实体在资源包中的的重要部分之一\n材料文件都被放置在资源包根目录的`materials`文件夹内，这些文件后缀名为“.entity”，实质上是一个json格式的文件\n## 总览\n材料用于指定渲染游戏不同部分的着色器文件，以及着色器应为每个元素的状态和设置。目前，游戏中的大部分内容都是经过硬编码形式以使用特定的材料，并且可能不会分配新的材料。更改这些元素的唯一方法是直接编辑它们的材质（可能也会对其他元素产生影响）。允许分配、删除默认或自定义材料的唯一功能是实体和粒子效果。\n\n## 语法结构\n大多数材料都继承了先前定义的材料的设置（底板材料），然后进一步构建它们。\n基本格式：\n```\n    \"新材料ID:底板材料ID\": {  //注意，这不是命名空间与ID!\n    \t//定义、状态、设置定义\n    },\n```\n\n\n一些物料文件包含大量的物料分支树。例如，几乎所有默认实体使用的材料最终都是entity.material文件中材料“ entity_static”为基础。\n以下是村民的材料：\n```\n    \"villager_v2_masked:entity_multitexture_masked\": {\n      \"depthFunc\": \"LessEqual\"\n    },\n```\n\n我们可以看到材料的名称为“ villager_v2_masked”，并且它是基于“ entity_multitexture_masked”材料的。\n可以找到“ entity_multitexture_masked”材料，它继承了“ entity_alphatest”的设置并在其上进一步构建：\n```\n    \"entity_multitexture_masked:entity_alphatest\": {\n      \"+defines\": [\n        \"MASKED_MULTITEXTURE\"\n      ],\n      \"+samplerStates\": [\n        {\n          \"samplerIndex\": 0,\n          \"textureWrap\": \"Clamp\"\n        },\n        {\n          \"samplerIndex\": 1,\n          \"textureWrap\": \"Clamp\"\n        }\n      ]\n    },\n```\n\n然后可以在“ entity_alphatest”中发现又是基于“ entity_nocull”\n```\n    \"entity_alphatest:entity_nocull\": {\n      \"+defines\": [ \"ALPHA_TEST\" ],\n      \"+samplerStates\": [\n        {\n          \"samplerIndex\": 1,\n          \"textureWrap\": \"Repeat\"\n        }\n      ],\n      \"msaaSupport\": \"Both\"\n    },\n```\n剩下的也是同理，就不解释了\n```\n    \"entity_nocull:entity\": {\n      \"+states\": [ \"DisableCulling\" ]\n    },\n```\n\n```\n    \"entity:entity_static\": {\n      \"+defines\": [ \"USE_OVERLAY\" ],\n\n      \"msaaSupport\": \"Both\"\n    },\n```\n\nentity\\_static没有冒号被其他材料跟随，表明它是该继承树的底部。\n\n```\n    \"entity_static\": {\n      \"vertexShader\": \"shaders/entity.vertex\",\n      \"vrGeometryShader\": \"shaders/entity.geometry\",\n      \"fragmentShader\": \"shaders/entity.fragment\",\n      \"vertexFields\": [\n        { \"field\": \"Position\" },\n        { \"field\": \"Normal\" },\n        { \"field\": \"UV0\" }\n      ],\n      \"variants\": [\n        {\n          \"skinning\": {\n            \"+defines\": [ \"USE_SKINNING\" ],\n            \"vertexFields\": [\n              { \"field\": \"Position\" },\n              { \"field\": \"BoneId0\" },\n              { \"field\": \"Normal\" },\n              { \"field\": \"UV0\" }\n            ]\n          }\n        },\n        {\n          \"skinning_color\": {\n            \"+defines\": [ \"USE_SKINNING\", \"USE_OVERLAY\" ],\n            \"+states\": [ \"Blending\" ],\n            \"vertexFields\": [\n              { \"field\": \"Position\" },\n              { \"field\": \"BoneId0\" },\n              { \"field\": \"Color\" },\n              { \"field\": \"Normal\" },\n              { \"field\": \"UV0\" }\n            ]\n          }\n        }\n      ],\n      \"msaaSupport\": \"Both\",\n      \"+samplerStates\": [\n        {\n          \"samplerIndex\": 0,\n          \"textureFilter\": \"Point\"\n        }\n      ]\n    },\n\n```\n## 材料预设\n| 材料ID | 解释 |\n| --- | --- |\n| alpha_block | 方块Alpha通道  |\n| alpha_block_color | 方块Alpha通道颜色  |\n| banner | 信标 |\n| banner_pole | 旗杆 |\n| beacon_beam | 信标光束 |\n| beacon_beam_transparent | 信标光束透明  |\n| charged_creeper | 闪电苦力怕 |\n| conduit_wind | 风管  |\n| entity | 实体基础 |\n| entity_alphablend | 用于透明纹理 |\n| entity_alphablend_nocolorentity_static | 实体静态颜色 |\n| entity_alphatest | 透明 |\n| entity_alphatest_change_color | 实体改变颜色 |\n| entity_alphatest_change_color_glint | 实体改变颜色闪烁 |\n| entity_alphatest_glint |   |\n| entity_alphatest_glint_item |   |\n| entity_alphatest_multicolor_tint |   |\n| entity_beam |   |\n| entity_beam\\_additive |   |\n| entity_change\\_color |   |\n| entity_change\\_color\\_glint |   |\n| entity_custom |   |\n| entity_dissolve\\_layer0 |   |\n| entity_dissolve\\_layer1 |   |\n| entity_emissive |   |\n| entity_emissive\\_alpha |   |\n| entity_emissive\\_alpha\\_one\\_sided |   |\n| entity_flat\\_color\\_line |   |\n| entity_glint |   |\n| entity_lead\\_base |   |\n| entity_loyalty\\_rope |   |\n| entity_multitexture |   |\n| entity_multitexture\\_alpha\\_test |   |\n| entity_multitexture\\_alpha\\_test\\_color\\_mask |   |\n| entity_multitexture\\_color\\_mask |   |\n| entity_multitexture\\_masked |   |\n| entity_multitexture\\_multiplicative\\_blend |   |\n| entity_nocull |   |\n| guardian\\_ghost |   |\n| item\\_in\\_hand |   |\n| item\\_in\\_hand\\_entity\\_alphatest |   |\n| item\\_in\\_hand\\_entity\\_alphatest\\_color |   |\n| item\\_in\\_hand\\_glint |   |\n| item\\_in\\_hand\\_multicolor\\_tint |   |\n| map |   |\n| map\\_decoration |   |\n| map\\_marker |   |\n| moving\\_block |   |\n| moving\\_block\\_alpha |   |\n| moving\\_block\\_alpha\\_seasons |   |\n| moving\\_block\\_alpha\\_single\\_side |   |\n| moving\\_block\\_blend |   |\n| moving\\_block\\_double\\_side |   |\n| moving\\_block\\_seasons |   |\n| opaque\\_block |   |\n| opaque\\_block\\_color |   |\n| opaque\\_block\\_color\\_uv2 | |","title":"材料"},{"path":"着色器（光影）.md","content":"","title":"着色器（光影）"},{"path":"JSON用户界面UI.md","content":"","title":"JSON用户界面UI"},{"path":"脚本引擎.md","content":"","title":"脚本引擎"},{"path":"技巧.md","content":"","title":"技巧"},{"path":"AddonAPI文档.md","content":"","title":"AddonAPI文档"}]